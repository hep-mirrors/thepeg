// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the Parameter, ParameterTBase and ParameterBase classes.
//

namespace ThePEG {

inline ParameterBase::ParameterBase(string newName,
				    string newDescription,
				    string newClassName,
				    const type_info & newTypeInfo, bool depSafe,
				    bool readonly, int limits)
  : InterfaceBase(newName, newDescription, newClassName, newTypeInfo, depSafe,
		  readonly), limit(limits) {}

inline ParameterBase::~ParameterBase() {}

inline bool ParameterBase::limited() const {
  return limit != Interface::nolimits;
}

inline bool ParameterBase::upperLimit() const {
  return limit == Interface::limited || limit == Interface::upperlim;
}

inline bool ParameterBase::lowerLimit() const {
  return limit == Interface::limited || limit == Interface::lowerlim;
}

inline void ParameterBase::setLimited() {
  limit = Interface::limited;
}

inline void ParameterBase::setUnlimited() {
  limit = Interface::nolimits;
}

template <typename Type>
inline ParameterTBase<Type>::
ParameterTBase(string newName, string newDescription, string newClassName,
	       const type_info & newTypeInfo, Type newUnit, bool depSafe,
	       bool readonly,  int limits)
  : ParameterBase(newName, newDescription, newClassName, newTypeInfo, depSafe,
		  readonly, limits), theUnit(newUnit) {}

inline ParameterTBase<string>::
ParameterTBase(string newName, string newDescription, string newClassName,
	       const type_info & newTypeInfo, bool depSafe, bool readonly)
  : ParameterBase(newName, newDescription, newClassName, newTypeInfo, depSafe,
		  readonly, false), isFileType(NoFile) {}

template <typename Type>
inline ParameterTBase<Type>::~ParameterTBase() {}

inline ParameterTBase<string>::~ParameterTBase() {}

template <typename Type>
inline void ParameterTBase<Type>::setDef(InterfacedBase & i) const
  throw(InterfaceException) {
  tset(i, tdef(i));
}

inline void ParameterTBase<string>::setDef(InterfacedBase & i) const
  throw(InterfaceException) {
  tset(i, tdef(i));
}

template <typename Type>
inline Type ParameterTBase<Type>::unit() const {
  return theUnit;
}

template <typename Type>
inline void ParameterTBase<Type>::unit(Type u) {
  theUnit = u;
}

template <typename Type>
inline void ParameterTBase<Type>::putUnit(ostream & os, Type val) const {
  if ( unit() > Type() )
    os << val/unit();
  else
    os << val;
}

// template <typename T, typename Type>
// inline Parameter<T,Type>::
// Parameter(string newName, string newDescription, Member newMember,
// 	  double newDef, double newMin, double newMax, bool depSafe,
// 	  bool readonly, bool islimited, SetFn newSetFn, GetFn newGetFn,
// 	  GetFn newMinFn, GetFn newMaxFn, GetFn newDefFn)
//   : ParameterTBase<Type>(newName, newDescription, ClassTraits<T>::className(),
// 			 typeid(T), depSafe, readonly, islimited),
//     theMember(newMember), theDef(newDef), theMin(newMin), theMax(newMax),
//     theSetFn(newSetFn), theGetFn(newGetFn), theDefFn(newDefFn),
//     theMinFn(newMinFn), theMaxFn(newMaxFn) {}

template <typename T, typename Type>
inline Parameter<T,Type>::~Parameter() {}

template <typename T>
inline Parameter<T,string>::~Parameter() {}

template <typename T, typename Type>
inline void Parameter<T,Type>::setSetFunction(SetFn sf) {
  theSetFn = sf;
}

template <typename T>
inline void Parameter<T,string>::setSetFunction(SetFn sf) {
  theSetFn = sf;
}

template <typename T, typename Type>
inline void Parameter<T,Type>::setGetFunction(GetFn gf) {
  theGetFn = gf;
}

template <typename T>
inline void Parameter<T,string>::setGetFunction(GetFn gf) {
  theGetFn = gf;
}

template <typename T, typename Type>
inline void Parameter<T,Type>::setDefaultFunction(GetFn df) {
  theDefFn = df;
}

template <typename T>
inline void Parameter<T,string>::setDefaultFunction(GetFn df) {
  theDefFn = df;
}

template <typename T, typename Type>
inline void Parameter<T,Type>::setMinFunction(GetFn mf) {
  theMinFn = mf;
}

template <typename T, typename Type>
inline void Parameter<T,Type>::setMaxFunction(GetFn mf) {
  theMaxFn = mf;
}

inline string ParameterTBase<string>::type() const {
  switch ( file() ) {
  case File: return "PF";
  case Directory: return "PD";
  default: return "Ps";
  }
}

inline void ParameterTBase<string>::file(FileType t) {
  isFileType = t;
}

inline void ParameterTBase<string>::fileType() {
  file(File);
}

inline void ParameterTBase<string>::directoryType() {
  file(Directory);
}

inline ParameterTBase<string>::FileType ParameterTBase<string>::file() const {
  return isFileType;
}

inline string ParameterTBase<string>::doxygenType() const {
  return "Character string parameter";
}

inline void ParameterTBase<string>::
set(InterfacedBase & i, string newValue) const throw(InterfaceException) {
  tset(i, StringUtils::stripws(newValue));
}

inline string ParameterTBase<string>::
get(const InterfacedBase & i) const throw(InterfaceException) {
  return tget(i);
}

inline string ParameterTBase<string>::
def(const InterfacedBase & i) const throw(InterfaceException) {
  return tdef(i);
}

inline string ParameterTBase<string>::
minimum(const InterfacedBase & i) const throw(InterfaceException) {
  return "";
}

inline string ParameterTBase<string>::
maximum(const InterfacedBase & i) const throw(InterfaceException) {
  return "";
}
    
}

