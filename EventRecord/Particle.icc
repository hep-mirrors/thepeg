// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the Particle class.
//

#include "ThePEG/PDT/ParticleData.h"

namespace ThePEG {

inline void * Particle::operator new(size_t) {
  return FixedAllocator<Particle>::allocate();
}

inline void Particle::operator delete(void * p, size_t) {
  FixedAllocator<Particle>::deallocate(p);
}

inline void * Particle::ParticleRep::operator new(size_t) {
  return FixedAllocator<Particle::ParticleRep>::allocate();
}

inline void Particle::ParticleRep::operator delete(void * p, size_t) {
  FixedAllocator<Particle::ParticleRep>::deallocate(p);
}

inline Particle::Particle()
  : theRep(0) {}

inline Particle::Particle(tcEventPDPtr newData)
  : theData(newData), theRep(0) {}

inline Particle::~Particle() {
  if ( theRep ) delete theRep;
  theRep = 0;
  theData = cEventPDPtr();
}

inline bool Particle::hasRep() const {
  return theRep;
}

inline Particle::ParticleRep &Particle:: rep() {
  if ( !hasRep() ) initFull();
  return *theRep;
}

inline const Particle::ParticleRep & Particle::rep() const {
  if ( !hasRep() ) initFull();
  return *theRep;
}

inline bool Particle::decayed() const {
  return hasRep() && !rep().theChildren.empty();
}

inline void Particle::removeChild(tPPtr c) {
  if ( hasRep() )
    rep().theChildren.erase(remove(rep().theChildren.begin(),
				   rep().theChildren.end(), c),
			    rep().theChildren.end());
}

inline void Particle::removeParent(tPPtr p) {
  if ( hasRep() )
    rep().theParents.erase(remove(rep().theParents.begin(),
				  rep().theParents.end(), p),
			   rep().theParents.end());
}

inline const ParticleVector & Particle::children() const {
  return rep().theChildren;
}

inline void Particle::addChild(tPPtr c) {
  rep().theChildren.push_back(c);
  (c->rep()).theParents.push_back(this);
}

inline void Particle::abandonChild(tPPtr child) {
  removeChild(child);
  child->removeParent(this);
}

const tParticleVector & Particle::parents() const {
  return rep().theParents;
}

inline tPPtr Particle::next() const {
  return hasRep()? rep().theNext: PPtr();
}

inline tcPPtr Particle::original() const {
  return previous()? tcPPtr(previous()->original()): tcPPtr(this);
}

inline tPPtr Particle::original() {
  return previous()? previous()->original(): tPPtr(this);
}

inline tcPPtr Particle::final() const {
  return next()? tcPPtr(next()->final()): tcPPtr(this);
}

inline tPPtr Particle::final() {
  return next()? next()->final(): tPPtr(this);
}

inline tPPtr Particle::previous() const {
  return hasRep()? rep().thePrevious: tPPtr();
}

inline void Particle::undecay() {
  if ( hasRep() ) {
    rep().theChildren.clear();
    rep().theNext = tPPtr();
  }
}

inline void Particle::decayMode(tDMPtr dm) {
  rep().theDecayMode = dm;
}

inline tDMPtr Particle::decayMode() const {
  return hasRep()? rep().theDecayMode: tDMPtr();
}

inline tcCBPtr Particle::colourInfo() const {
  return hasRep()? rep().theColourInfo: CBPtr();
}

inline tCBPtr Particle::colourInfo() {
  if ( !rep().theColourInfo ) rep().theColourInfo = new_ptr(ColourBase());
  return rep().theColourInfo;
}

inline void Particle::colourInfo(tCBPtr c) {
  rep().theColourInfo = c;
}

inline bool Particle::hasColourInfo() const {
  return hasRep() && rep().theColourInfo;
}

inline bool Particle::coloured() const {
  return data().coloured();
}

inline bool Particle::hasColour(bool anti) const {
  return data().hasColour(anti);
}

inline bool Particle::hasAntiColour() const {
  return data().hasAntiColour();
}

inline tColinePtr Particle::antiColourLine() const {
  return hasColourInfo()? colourInfo()->antiColourLine(): tColinePtr();
}

inline tColinePtr Particle::colourLine(bool anti) const {
  if ( anti ) return antiColourLine();
  return hasColourInfo()? colourInfo()->colourLine(): tColinePtr();
}

inline bool Particle::hasColourLine(tcColinePtr line, bool anti) const {
  return hasColourInfo()? colourInfo()->hasColourLine(line, anti): false;
}

inline bool Particle::hasAntiColourLine(tcColinePtr line) const {
  return hasColourLine(line, true);
}

template <typename Iterator>
inline typename std::iterator_traits<Iterator>::value_type Particle::
antiColourNeighbour(Iterator first, Iterator last) const {
   return colourNeighbour(first, last, true);
}

inline void Particle::antiColourNeighbour(tPPtr p) {
  colourNeighbour(p, true);
}

inline tPPtr Particle::incomingAntiColour() const {
  return incomingColour(true);
}

inline void Particle::incomingColour(tPPtr p, bool anti) {
  p->outgoingColour(this, anti);
}

inline void Particle::incomingAntiColour(tPPtr p) {
  p->outgoingColour(this, true);
}

inline tPPtr Particle::outgoingAntiColour() const {
  return outgoingColour(true);
}

inline void Particle::outgoingAntiColour(tPPtr p) {
  outgoingColour(p, true);
}

inline void Particle::antiColourFlow(tPPtr child) {
  colourFlow(child, true);
}

inline void Particle::colourFlow(tPPtr child, bool anti) {
  outgoingColour(child, anti);
}

inline void Particle::antiColourConnect(tPPtr neighbour) {
  colourConnect(neighbour, true);
}

inline void Particle::colourConnect(tPPtr neighbour, bool anti) {
  colourNeighbour(neighbour, anti);
}

inline void Particle::resetColour() {
  if ( hasColourInfo() ) rep().theColourInfo = CBPtr();
}

inline tStepPtr Particle::birthStep() const {
  return rep().theBirthStep;
}

inline const ParticleData & Particle::data() const {
  return *theData;
}

inline tcEventPDPtr Particle::dataPtr() const {
  return theData;
}

inline string Particle::PDGName() const {
  return data().PDGName();
}

inline long Particle::id() const {
  return data().id();
}

inline tcSpinPtr Particle::spinInfo() const {
  return hasRep()? rep().theSpinInfo: SpinPtr();
}

inline tSpinPtr Particle::spinInfo() {
  return hasRep()? rep().theSpinInfo: SpinPtr();
}

inline void Particle::spinInfo(tSpinPtr s) {
  rep().theSpinInfo = s;
}

inline const Lorentz5Momentum & Particle::momentum() const {
  return theMomentum;
}

inline void Particle::set3Momentum(const Momentum3 & p) {
  theMomentum.setVect(p);
  theMomentum.rescaleEnergy();
}

inline void Particle::setMomentum(const LorentzMomentum & p) {
  theMomentum = p;
}

inline void Particle::set5Momentum(const Lorentz5Momentum & p) {
  theMomentum = p;
}

inline void  Particle::mass(Energy newMass) {
  return theMomentum.setMass(newMass);
}

inline void  Particle::lifeTime(Length newLifeTime) {
  return rep().theLifeLength.setMass(newLifeTime);
}

inline Energy Particle::mass() const {
  return momentum().mass();
}

inline Energy Particle::nominalMass() const {
  return data().mass();
}

inline Energy2 Particle::scale() const {
  return rep().theScale;
}

inline void Particle::scale(Energy2 Q2) {
  rep().theScale = Q2;
}

inline const LorentzPoint & Particle::vertex() const {
  return rep().theVertex;
}

inline LorentzPoint Particle::decayVertex() const {
  LorentzPoint r(vertex() + lifeLength());
  return r;
}

inline LorentzPoint Particle::labDecayVertex() const {
  LorentzPoint r(labVertex() + lifeLength());
  return r;
}

inline const Lorentz5Distance & Particle::lifeLength() const {
  return rep().theLifeLength;
}

inline void Particle::setVertex(const LorentzPoint & p) {
  rep().theVertex = p;
}

inline void Particle::setLifeLength(const Distance & d) {
  rep().theLifeLength.setVect(d);
  rep().theLifeLength.rescaleEnergy();
}

inline void Particle::setLifeLength(const LorentzDistance & d) {
  rep().theLifeLength = d;
}

inline void Particle::setLifeLength(const Lorentz5Distance & d) {
  rep().theLifeLength = d;
}

inline Time Particle::lifeTime() const {
  return lifeLength().m();
}

inline void Particle::boost(double bx, double by, double bz) {
  transform(LorentzRotation(Vector3(bx, by, bz)));
}

inline void Particle::deepBoost(double bx, double by, double bz) {
  deepTransform(LorentzRotation(Vector3(bx, by, bz)));
}

inline void Particle::boost(const Vector3 & p) {
  transform(LorentzRotation(p));
}

inline void Particle::deepBoost(const Vector3 & p) {
  deepTransform(LorentzRotation(p));
}

inline void Particle::mirror() {
  theMomentum.setZ(-theMomentum.z());
}

inline int Particle::number() const {
  return rep().theNumber;
}

inline void Particle::number(int newNumber) {
  rep().theNumber = newNumber;
}

inline Energy Particle::massError() const {
  return theMomentum.massError();
}

inline Energy Particle::energyError() const {
  return theMomentum.energyError();
}

inline Energy Particle::rhoError() const {
  return theMomentum.rhoError();
}

inline void Particle::rescaleEnergy() {
  theMomentum.rescaleEnergy();
}

inline void Particle::rescaleRho() {
  theMomentum.rescaleRho();
}

inline void Particle::rescaleMass() {
  theMomentum.rescaleMass();
}

inline Energy2 Particle::mt2() const {
  return sqr(momentum().t()) - sqr(momentum().z());
}

inline Energy Particle::mt() const {
  return sqrt(mt2());
}

inline Energy2 Particle::perpmass2() const {
  return momentum().perp2() + momentum().mass2();
}

inline Energy Particle::perpmass() const {
  return sqrt(perpmass2());
}

inline double Particle::rapidity() const {
  return ( Pplus() > 0.0*GeV && Pminus() > 0.0*GeV )?
    0.5*log(Pplus()/Pminus()) : Constants::MaxFloat;
}

inline double Particle::eta() const {
  Energy rho = momentum().rho();
  return rho > abs(momentum().z())?
    0.5*log((rho+momentum().z())/(rho-momentum().z())) : Constants::MaxFloat;
}

inline Energy Particle::Pplus() const {
  return momentum().plus();
}

inline Energy Particle::Pminus() const {
  return momentum().minus();
}

inline const EIVector & Particle::getInfo() const {
  return rep().theExtraInfo;
}

inline EIVector & Particle::getInfo() {
  return rep().theExtraInfo;
}

template <typename Cont>
inline void Particle::
PrintParticles(ostream & os, const Cont & c, tcStepPtr step) {
  PrintParticles(os, c.begin(), c.end(), step);
}

}
