// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the Step class.
//
#include "Collision.h"
#include "SubProcess.h"

namespace ThePEG {

inline void * Step::operator new(size_t) {
  return FixedAllocator<Step>::allocate();
}

inline void Step::operator delete(void * p, size_t) {
  FixedAllocator<Step>::deallocate(p);
}

inline Step::~Step() {}

inline tcEventBasePtr Step::handler() const {
  return theHandler;
}

inline tCollPtr Step::collision() const {
  return theCollision;
}

inline const SubProcessVector & Step::subProcesses() const {
  return theSubProcesses;
}

template <class OutputIterator>
inline void Step::selectFinalState(OutputIterator r) const {
  select(r, SelectFinalState());
}

inline tPVector Step::getFinalState() const {
  tPVector ret;
  selectFinalState(back_inserter(ret));
  return ret;
}

inline const PPair & Step::incoming() const {
  return collision()->incoming();
}

inline const ParticleSet & Step::particles() const {
  return theParticles;
}

inline const ParticleSet & Step::intermediates() const {
  return theIntermediates;
}

inline const ParticleSet & Step::all() const {
  return allParticles;
}

inline tPPtr Step::find(tcPPtr p) const {
  tPPtr r = const_ptr_cast<tPPtr>(p);
  if ( !member(all(), r) ) return tPPtr();
  return r;
}

inline void Step::collision(tCollPtr c) {
  theCollision = c;
}

inline void Step::handler(tcEventBasePtr sh) {
  theHandler = sh;
}

template <typename Cont>
inline tParticleSet Step::getCurrent(const Cont & c) const {
  return getCurrent(c.begin(), c.end());
}

template <typename CIterator>
inline bool Step::
addDecayProduct(tcPPtr parent, CIterator firstChild, CIterator lastChild,
		bool fixColour) {
  for ( ; firstChild != lastChild; ++firstChild )
    if ( !addDecayProduct(parent, *firstChild, fixColour) ) return false;
  return true;
}

template <typename CIterator>
inline bool Step::
removeDecayProduct(tcPPtr parent, CIterator firstChild, CIterator lastChild) {
  bool success = true;
  for ( ; firstChild != lastChild; ++firstChild )
    if ( !removeDecayProduct(parent, *firstChild) ) success = false;
  return success;
}

template <typename PIterator>
inline vector<tPVector> Step::getSinglets(PIterator first, PIterator last) {
  tParticleSet left(first, last);
  return getSinglets(left);
}

}
