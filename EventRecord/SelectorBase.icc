// -*- C++ -*-
//
// SelectorBase.icc is a part of ThePEG - Toolkit for HEP Event Generation
// Copyright (C) 1999-2007 Leif Lonnblad
//
// ThePEG is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the SelectorBase and ParticleSelector classes.
//

namespace ThePEG {

inline SelectorBase::SelectorBase() {}

inline SelectorBase::~SelectorBase() {}

inline bool SelectorBase::Check(const Particle &) {
  return true;
}

inline bool SelectorBase::Intermediate() {
  return true;
}

inline bool SelectorBase::FinalState() {
  return true;
}

inline bool SelectorBase::AllSteps() {
  return true;
}

inline bool SelectorBase::AllCollisions() {
  return true;
}

inline bool SelectorBase::check(const Particle &  p) const {
  return Check(p);
}

inline bool SelectorBase::finalState() const {
  return FinalState();
}

inline bool SelectorBase::intermediate() const {
  return Intermediate();
}

inline bool SelectorBase::allSteps() const {
  return AllSteps();
}

inline bool SelectorBase::allCollisions() const {
  return AllCollisions();
}

template <class T>
inline ParticleSelector<T>::ParticleSelector() {}

template <class T>
inline ParticleSelector<T>::~ParticleSelector() {}

template <class T>
inline bool ParticleSelector<T>::Check(const Particle & p) {
  return T::Check(p);
}

template <class T>
inline bool ParticleSelector<T>::Intermediate() {
  return T::Intermediate();
}

template <class T>
inline bool ParticleSelector<T>::FinalState() {
  return T::FinalState();
}

template <class T>
inline bool ParticleSelector<T>::AllSteps() {
  return T::AllSteps();
}

template <class T>
inline bool ParticleSelector<T>::AllCollisions() {
  return T::AllCollisions();
}

template <class T>
inline bool ParticleSelector<T>::check(const Particle &  p) const {
  return Check(p);
}

template <class T>
inline bool ParticleSelector<T>::finalState() const {
  return FinalState();
}

template <class T>
inline bool ParticleSelector<T>::intermediate() const {
  return Intermediate();
}

template <class T>
inline bool ParticleSelector<T>::allSteps() const {
  return AllSteps();
}

template <class T>
inline bool ParticleSelector<T>::allCollisions() const {
  return AllCollisions();
}

inline SelectIfNot::SelectIfNot(const SelectorBase & S) 
  : s(S) {}

inline SelectIfNot::SelectIfNot(const SelectIfNot & S) 
  : SelectorBase(S), s(S.s) {}

inline bool SelectIfNot::check(const Particle &  p) const {
  return !s.check(p);
}

inline bool SelectIfNot::finalState() const {
  return !s.finalState();
}

inline bool SelectIfNot::intermediate() const {
  return !s.intermediate();
}

inline bool SelectIfNot::allSteps() const {
  return !s.allSteps();
}

inline bool SelectIfNot::allCollisions() const {
  return !s.allCollisions();
}

inline SelectIfBoth::SelectIfBoth(const SelectorBase & S1,
				  const SelectorBase & S2)
  : s1(S1), s2(S2) {}

inline SelectIfBoth::SelectIfBoth(const SelectIfBoth & S)
  : SelectorBase(S), s1(S.s1), s2(S.s2) {}

inline bool SelectIfBoth::check(const Particle &  p) const {
  return s1.check(p) && s2.check(p);
}

inline bool SelectIfBoth::finalState() const {
  return s1.finalState() && s2.finalState();
}

inline bool SelectIfBoth::intermediate() const {
  return s1.intermediate() && s2.intermediate();
}

inline bool SelectIfBoth::allSteps() const {
  return s1.allSteps() && s2.allSteps();
}

inline bool SelectIfBoth::allCollisions() const {
  return s1.allCollisions() && s2.allCollisions();
}

inline SelectIfEither::SelectIfEither(const SelectorBase & S1,
				      const SelectorBase & S2)
  : s1(S1), s2(S2) {}

inline SelectIfEither::SelectIfEither(const SelectIfEither & S)
  : SelectorBase(S), s1(S.s1), s2(S.s2) {}

inline bool SelectIfEither::check(const Particle &  p) const {
  return s1.check(p) || s2.check(p);
}

inline bool SelectIfEither::finalState() const {
  return s1.finalState() || s2.finalState();
}

inline bool SelectIfEither::intermediate() const {
  return s1.intermediate() || s2.intermediate();
}

inline bool SelectIfEither::allSteps() const {
  return s1.allSteps() || s2.allSteps();
}

inline bool SelectIfEither::allCollisions() const {
  return s1.allCollisions() || s2.allCollisions();
}

template <typename OutputIterator, typename Container>
inline void copyIfCheck(OutputIterator r, const Container & c,
			const SelectorBase & s) {
  for ( typename Container::const_iterator it = c.begin();
	it != c.end(); ++it )
    if ( s.check(**it) ) *r++ = *it;
}

}

