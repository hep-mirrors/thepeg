// -*- C++ -*-
//
// RandomGenerator.icc is a part of ThePEG - Toolkit for HEP Event Generation
// Copyright (C) 1999-2007 Leif Lonnblad
//
// ThePEG is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the RandomGenerator class.
//

namespace ThePEG {

inline double RandomGenerator::rnd() {
  if ( nextNumber == theNumbers.end() ) fill();
  return *nextNumber++;
}

template <typename Unit>
inline Unit RandomGenerator::rnd(Unit b) {
  return b*rnd();
}

template <typename Unit>
inline Unit RandomGenerator::rnd(Unit a, Unit b) {
  return a + rnd(b - a);
}

inline RandomGenerator::RndVector RandomGenerator::rndvec(int n) {
  RndVector ret(n);
  for ( int i = 0; i < n; ++i ) ret[i] = rnd();
  return ret;
}

inline double RandomGenerator::operator()() {
  return rnd();
}

inline long RandomGenerator::operator()(long N) {
  return long(rnd()*double(N));
}

template <typename OutputIterator>
inline void RandomGenerator::rnd(OutputIterator o, size_type n) {
  while ( n-- ) *o++ = rnd();
}

inline void RandomGenerator::push_back(double r) {
  if ( r > 0.0 && r < 1.0 && nextNumber != theNumbers.begin() )
    *--nextNumber = r;
}

inline void RandomGenerator::pop_back() {
  if ( nextNumber != theNumbers.end() ) ++nextNumber;
}

inline void RandomGenerator::flush() {
  nextNumber = theNumbers.end();
}

inline bool RandomGenerator::rndbool(double p1, double p2) {
  return rndbool(p1/(p1 + p2));
}

inline int RandomGenerator::rnd2(double p0, double p1) {
  return rndbool(p0, p1)? 0: 1;
}

inline int RandomGenerator::rnd3(double p0, double p1, double p2) {
  return 1 + rndsign(p0, p1, p2);
}

inline double RandomGenerator::rndExp() {
  return -log(rnd());
}

template <typename Unit>
inline Unit RandomGenerator::rndExp(Unit mean) {
  return mean*rndExp();
}

inline double RandomGenerator::rndGauss() {
  if ( gaussSaved ) {
    gaussSaved = false;
    return savedGauss;
  }
  double r = sqrt(-2.0*log(rnd()));
  double phi = rnd()*2.0*Constants::pi;
  savedGauss = r*cos(phi);
  gaussSaved = true;
  return r*sin(phi);
}

template <typename Unit>
inline Unit RandomGenerator::rndGauss(Unit sigma, Unit mean) {
  return mean + sigma*rndGauss();
}

template <typename Unit>
inline Unit RandomGenerator::rndBW(Unit mean, Unit gamma) {
  if ( gamma <= Unit() ) return mean;
  return mean + 0.5*gamma*tan(rnd(atan(-2.0*mean/gamma), Constants::pi/2));
}

template <typename Unit>
inline Unit RandomGenerator::rndBW(Unit mean, Unit gamma, Unit cut) {
  if ( gamma <= Unit() || cut <= Unit() ) return mean;
  return mean + 0.5*gamma*tan(rnd(atan(-2.0*min(mean,cut)/gamma),
				  atan(2.0*cut/gamma)));
}

template <typename Unit>
inline Unit RandomGenerator::rndRelBW(Unit mean, Unit gamma) {
  if ( gamma <= Unit() ) return mean;
  return sqrt(sqr(mean) + mean*gamma*tan(rnd(atan(-mean/gamma),
					     Constants::pi/2)));
}

template <typename Unit>
inline Unit RandomGenerator::rndRelBW(Unit mean, Unit gamma, Unit cut) {
  if ( gamma <= Unit() || cut <= Unit() ) return mean;
  double minarg = cut > mean? -mean/gamma:
    (sqr(mean - cut) - sqr(mean))/(gamma*mean);
  double maxarg = (sqr(mean + cut) - sqr(mean))/(mean*gamma);
  return sqrt(sqr(mean) + mean*gamma*tan(rnd(atan(minarg), atan(maxarg))));
}

inline gsl_rng * RandomGenerator::getGslInterface() {
  return gsl;
}

}
