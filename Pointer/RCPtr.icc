// -*- C++ -*-
//
// RCPtr.icc is a part of ThePEG - Toolkit for HEP Event Generation
// Copyright (C) 1999-2007 Leif Lonnblad
//
// ThePEG is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of the
// RCPtrBase, RCPtr, ConstRCPtr, TransientRCPtr and
// TransientConstRCPtr classes.
//

namespace ThePEG {
namespace Pointer {

inline void RCPtrBase::increment(const ReferenceCounted * rcp) {
  if ( rcp ) rcp->incrementReferenceCount();
}

inline bool RCPtrBase::release(const ReferenceCounted * rcp) {
  return rcp && rcp->decrementReferenceCount();
}

// RCPtr

template <typename T>
inline RCPtr<T>::RCPtr()
  : ptr(0) {}

template <typename T>
inline RCPtr<T>::RCPtr(const RCPtr & p)
  : ptr(p.ptr) {
  increment();
}

template <typename T>
template <typename UPtr>
inline RCPtr<T>::RCPtr(const UPtr & u)
  : ptr(PtrTraits<UPtr>::barePointer(u)) {
  increment();
}

template <typename T>
inline RCPtr<T>::RCPtr(pointer p)
  : ptr(p) {
  increment();
}


template <typename T>
inline RCPtr<T>::~RCPtr(){
  release();
}

template <typename T>
inline RCPtr<T> RCPtr<T>::Create() {
  RCPtr<T> p;
  return p.create();
}

template <typename T>
inline RCPtr<T> RCPtr<T>::Create(const_reference t) {
  RCPtr<T> p;
  return p.create(t);
}

template <typename T>
inline RCPtr<T> & RCPtr<T>::create(const_reference t) {
  release();
  ptr = new T(t);
  //  increment();
  return *this;
}

template <typename T>
inline RCPtr<T> & RCPtr<T>::create() {
  release();
  ptr = new T;
  //  increment();
  return *this;
}

template <typename T>
inline RCPtr<T> & RCPtr<T>::operator=(const RCPtr & p) {
  if ( ptr == p.ptr ) return *this;
  release();
  ptr = p.ptr;
  increment();
  return *this;
}

template <typename T>
template <typename UPtr>
inline RCPtr<T> & RCPtr<T>::operator=(const UPtr & u) {
  if ( ptr == PtrTraits<UPtr>::barePointer(u) ) return *this;
  release();
  ptr = PtrTraits<UPtr>::barePointer(u);
  increment();
  return *this;
}

template <typename T>
template <typename UPtr>
inline RCPtr<T> & RCPtr<T>::assignDynamic(const UPtr & u) {
  pointer up = dynamic_cast<pointer>(PtrTraits<UPtr>::barePointer(u));
  if ( ptr == up ) return *this;
  release();
  ptr = up;
  increment();
  return *this;
}

template <typename T>
template <typename UPtr>
inline RCPtr<T> & RCPtr<T>::assignConst(const UPtr & u) {
  pointer up = const_cast<pointer>(PtrTraits<UPtr>::barePointer(u));
  if ( ptr == up ) return *this;
  release();
  ptr = up;
  increment();
  return *this;
}

template <typename T>
inline void RCPtr<T>::swap(RCPtr & p) {
  const pointer tmp = ptr;
  ptr = p.ptr;
  p.ptr = tmp;
  //  std::swap(ptr, p.ptr);
}  

template <typename T>
inline bool RCPtr<T>::operator==(const RCPtr & p) const {
  return ptr == p.ptr;
}

template <typename T>
inline bool RCPtr<T>::operator==(const_pointer p) const {
  return ptr == p;
}

template <typename T>
template <typename UPtr>
inline bool RCPtr<T>::operator==(const UPtr & u) const {
  return ptr == PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool RCPtr<T>::operator!=(const RCPtr & p) const {
  return ptr != p.ptr;
}

template <typename T>
inline bool RCPtr<T>::operator!=(const_pointer p) const {
  return ptr != p;
}

template <typename T>
template <typename UPtr>
inline bool RCPtr<T>::operator!=(const UPtr & u) const {
  return ptr != PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool RCPtr<T>::operator<(const RCPtr & p) const {
  return ( ptr && p.ptr && ptr->uniqueId != p.ptr->uniqueId ) ?
    ptr->uniqueId < p.ptr->uniqueId : ptr < p.ptr;
}

template <typename T>
inline bool RCPtr<T>::operator<(const_pointer p) const {
  return ptr < p;
}

template <typename T>
inline bool RCPtr<T>::operator!() const {
  return !ptr;
}

template <typename T>
inline RCPtr<T>::operator T * () const {
  return ptr;
}

template <typename T>
inline typename RCPtr<T>::pointer RCPtr<T>::operator->() const {
  return ptr;
}

template <typename T>
inline typename RCPtr<T>::reference RCPtr<T>::operator*() const {
  return *ptr;
}

template <typename T>
inline void RCPtr<T>::release() {
  if ( RCPtrBase::release(ptr) )  delete ptr;
}

template <typename T>
inline void RCPtr<T>::increment() {
  RCPtrBase::increment(ptr);
}
// ConstRCPtr

template <typename T>
inline ConstRCPtr<T>::ConstRCPtr()
  : ptr(0) {}

template <typename T>
inline ConstRCPtr<T>::ConstRCPtr(const ConstRCPtr & p)
  : ptr(p.ptr) {
  increment();
}

template <typename T>
template <typename UPtr>
inline ConstRCPtr<T>::ConstRCPtr(const UPtr & u)
  : ptr(PtrTraits<UPtr>::barePointer(u)) {
  increment();
}

template <typename T>
inline ConstRCPtr<T>::ConstRCPtr(const_pointer p)
  : ptr(p) {
  increment();
}


template <typename T>
inline ConstRCPtr<T>::~ConstRCPtr(){
  release();
}

template <typename T>
inline ConstRCPtr<T> & ConstRCPtr<T>::
operator=(const ConstRCPtr & p) {
  if ( ptr == p.ptr ) return *this;
  release();
  ptr = p.ptr;
  increment();
  return *this;
}
  
template <typename T>
template <typename UPtr>
inline ConstRCPtr<T> & ConstRCPtr<T>::operator=(const UPtr & u) {
  if ( ptr == PtrTraits<UPtr>::barePointer(u) ) return *this;
  release();
  ptr = PtrTraits<UPtr>::barePointer(u);
  increment();
  return *this;
}

template <typename T>
template <typename UPtr>
inline ConstRCPtr<T> & ConstRCPtr<T>::
assignDynamic(const UPtr & u) {
  const_pointer up =
    dynamic_cast<const_pointer>(PtrTraits<UPtr>::barePointer(u));
  if ( ptr == up ) return *this;
  release();
  ptr = up;
  increment();
  return *this;
}

template <typename T>
inline void ConstRCPtr<T>::swap(ConstRCPtr & p) {
  const const_pointer tmp = ptr;
  ptr = p.ptr;
  p.ptr = tmp;
  //  std::swap(ptr, p.ptr);
}  

template <typename T>
inline bool ConstRCPtr<T>::operator==(const ConstRCPtr & p) const {
  return ptr == p.ptr;
}

template <typename T>
inline bool ConstRCPtr<T>::operator==(const_pointer p) const {
  return ptr == p;
}

template <typename T>
template <typename UPtr>
inline bool ConstRCPtr<T>::operator==(const UPtr & u) const {
  return ptr == PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool ConstRCPtr<T>::operator!=(const ConstRCPtr & p) const {
  return ptr != p.ptr;
}

template <typename T>
inline bool ConstRCPtr<T>::operator!=(const_pointer p) const {
  return ptr != p;
}

template <typename T>
template <typename UPtr>
inline bool ConstRCPtr<T>::operator!=(const UPtr & u) const {
  return ptr != PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool ConstRCPtr<T>::operator<(const ConstRCPtr & p) const {
  return ( ptr && p.ptr && ptr->uniqueId != p.ptr->uniqueId ) ?
    ptr->uniqueId < p.ptr->uniqueId : ptr < p.ptr;
}

template <typename T>
inline bool ConstRCPtr<T>::operator<(const_pointer p) const {
  return ptr < p;
}

template <typename T>
inline bool ConstRCPtr<T>::operator!() const {
  return !ptr;
}

template <typename T>
inline ConstRCPtr<T>::operator const T * () const {
  return ptr;
}

template <typename T>
inline typename ConstRCPtr<T>::const_pointer
ConstRCPtr<T>::operator->() const {
  return ptr;
}

template <typename T>
inline typename ConstRCPtr<T>::const_reference
ConstRCPtr<T>::operator*() const {
  return *ptr;
}

template <typename T>
inline void ConstRCPtr<T>::release() {
  if ( RCPtrBase::release(ptr) ) delete ptr;
}

template <typename T>
inline void ConstRCPtr<T>::increment() {
  RCPtrBase::increment(ptr);
}

// TransientRCPtr

template <typename T>
inline TransientRCPtr<T>::TransientRCPtr()
  : ptr(0) {}

template <typename T>
inline TransientRCPtr<T>::TransientRCPtr(const TransientRCPtr & p)
  : ptr(p.ptr) {
}

template <typename T>
template <typename UPtr>
inline TransientRCPtr<T>::TransientRCPtr(const UPtr & u)
  : ptr(PtrTraits<UPtr>::barePointer(u)) {
}

template <typename T>
inline TransientRCPtr<T>::TransientRCPtr(pointer p)
  : ptr(p) {}


template <typename T>
inline TransientRCPtr<T>::~TransientRCPtr(){
}

template <typename T>
inline TransientRCPtr<T> & TransientRCPtr<T>::
operator=(const TransientRCPtr & p) {
  ptr = p.ptr;
  return *this;
}
  
template <typename T>
template <typename UPtr>
inline TransientRCPtr<T> & TransientRCPtr<T>::
operator=(const UPtr & u) {
  ptr = PtrTraits<UPtr>::barePointer(u);
  return *this;
}

template <typename T>
template <typename UPtr>
inline TransientRCPtr<T> & TransientRCPtr<T>::
assignDynamic(const UPtr & u) {
  ptr = dynamic_cast<pointer>(PtrTraits<UPtr>::barePointer(u));
  return *this;
}

template <typename T>
template <typename UPtr>
inline TransientRCPtr<T> & TransientRCPtr<T>::
assignConst(const UPtr & u) {
  ptr = const_cast<pointer>(PtrTraits<UPtr>::barePointer(u));
  return *this;
}

template <typename T>
inline bool TransientRCPtr<T>::
operator==(const TransientRCPtr & p) const {
  return ptr == p.ptr;
}

template <typename T>
inline bool TransientRCPtr<T>::operator==(const_pointer p) const {
  return ptr == p;
}

template <typename T>
template <typename UPtr>
inline bool TransientRCPtr<T>::operator==(const UPtr & u) const {
  return ptr == PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool TransientRCPtr<T>::
operator!=(const TransientRCPtr & p) const {
  return ptr != p.ptr;
}

template <typename T>
inline bool TransientRCPtr<T>::operator!=(const_pointer p) const {
  return ptr != p;
}

template <typename T>
template <typename UPtr>
inline bool TransientRCPtr<T>::operator!=(const UPtr & u) const {
  return ptr != PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool TransientRCPtr<T>::operator<(const TransientRCPtr & p) const {
  return ( ptr && p.ptr && ptr->uniqueId != p.ptr->uniqueId ) ?
    ptr->uniqueId < p.ptr->uniqueId : ptr < p.ptr;
}

template <typename T>
inline bool TransientRCPtr<T>::operator<(const_pointer p) const {
  return ptr < p;
}

template <typename T>
inline bool TransientRCPtr<T>::operator!() const {
  return !ptr;
}

template <typename T>
inline TransientRCPtr<T>::operator T * () const {
  return ptr;
}

template <typename T>
inline typename TransientRCPtr<T>::pointer
TransientRCPtr<T>::operator->() const {
  return ptr;
}

template <typename T>
inline typename TransientRCPtr<T>::reference
TransientRCPtr<T>::operator*() const {
  return *ptr;
}

// TransientConstRCPtr

template <typename T>
inline TransientConstRCPtr<T>::TransientConstRCPtr()
  : ptr(0) {}

template <typename T>
inline TransientConstRCPtr<T>::
TransientConstRCPtr(const TransientConstRCPtr & p)
  : ptr(p.ptr) {}

template <typename T>
template <typename UPtr>
inline TransientConstRCPtr<T>::TransientConstRCPtr(const UPtr & u)
  : ptr(PtrTraits<UPtr>::barePointer(u)) {}

template <typename T>
inline TransientConstRCPtr<T>::TransientConstRCPtr(const_pointer p)
  : ptr(p) {}


template <typename T>
inline TransientConstRCPtr<T>::~TransientConstRCPtr() {}

template <typename T>
inline TransientConstRCPtr<T> & TransientConstRCPtr<T>::
operator=(const TransientConstRCPtr & p) {
  ptr = p.ptr;
  return *this;
}
  
template <typename T>
template <typename UPtr>
inline TransientConstRCPtr<T> & TransientConstRCPtr<T>::
operator=(const UPtr & u) {
  ptr = PtrTraits<UPtr>::barePointer(u);
  return *this;
}

template <typename T>
template <typename UPtr>
inline TransientConstRCPtr<T> & TransientConstRCPtr<T>::
assignDynamic(const UPtr & u) {
  ptr = dynamic_cast<const_pointer>(PtrTraits<UPtr>::barePointer(u));
  return *this;
}

template <typename T>
inline bool TransientConstRCPtr<T>::
operator==(const TransientConstRCPtr & p) const {
  return ptr == p.ptr;
}

template <typename T>
inline bool TransientConstRCPtr<T>::operator==(const_pointer p) const {
  return ptr == p;
}

template <typename T>
template <typename UPtr>
inline bool TransientConstRCPtr<T>::operator==(const UPtr & u) const {
  return ptr == PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool TransientConstRCPtr<T>::
operator!=(const TransientConstRCPtr & p) const {
  return ptr != p.ptr;
}

template <typename T>
inline bool TransientConstRCPtr<T>::operator!=(const_pointer p) const {
  return ptr != p;
}

template <typename T>
template <typename UPtr>
inline bool TransientConstRCPtr<T>::operator!=(const UPtr & u) const {
  return ptr != PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool TransientConstRCPtr<T>::
operator<(const TransientConstRCPtr & p) const {
  return ( ptr && p.ptr && ptr->uniqueId != p.ptr->uniqueId ) ?
    ptr->uniqueId < p.ptr->uniqueId : ptr < p.ptr;
}

template <typename T>
inline bool TransientConstRCPtr<T>::operator<(const_pointer p) const {
  return ptr < p;
}

template <typename T>
inline bool TransientConstRCPtr<T>::operator!() const {
  return !ptr;
}

template <typename T>
inline TransientConstRCPtr<T>::operator const T * () const {
  return ptr;
}

template <typename T>
inline typename TransientConstRCPtr<T>::const_pointer
TransientConstRCPtr<T>::operator->() const {
  return ptr;
}

template <typename T>
inline typename TransientConstRCPtr<T>::const_reference
TransientConstRCPtr<T>::operator*() const {
  return *ptr;
}

}
}

template <typename T>
void std::swap(ThePEG::Pointer::RCPtr<T> & t1,
	       ThePEG::Pointer::RCPtr<T> & t2) {
  t1.swap(t2);
}

template <typename T>
void std::swap(ThePEG::Pointer::ConstRCPtr<T> & t1,
	       ThePEG::Pointer::ConstRCPtr<T> & t2) {
  t1.swap(t2);
}

