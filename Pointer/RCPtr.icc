// -*- C++ -*-
//
// This is the implementation of the inlined member functions of the
// RCPtrBase, RCPtr, ConstRCPtr, TransientRCPtr and
// TransientConstRCPtr classes.
//

namespace ThePEG {
namespace Pointer {

inline void RCPtrBase::increment(const ReferenceCounted * rcp) {
  if ( rcp ) rcp->incrementReferenceCount();
}

inline bool RCPtrBase::release(const ReferenceCounted * rcp) {
  return rcp && rcp->decrementReferenceCount();
}

// RCPtr

template <typename T>
inline RCPtr<T>::RCPtr()
  : thePointer(0) {}

template <typename T>
inline RCPtr<T>::RCPtr(const RCPtr & p)
  : thePointer(p.thePointer) {
  increment();
}

template <typename T>
template <typename UPtr>
inline RCPtr<T>::RCPtr(const UPtr & u)
  : thePointer(PtrTraits<UPtr>::barePointer(u)) {
  increment();
}

template <typename T>
inline RCPtr<T>::RCPtr(pointer p)
  : thePointer(p) {
  increment();
}


template <typename T>
inline RCPtr<T>::~RCPtr(){
  release();
}

template <typename T>
inline RCPtr<T> RCPtr<T>::Create() {
  RCPtr<T> p;
  return p.create();
}

template <typename T>
inline RCPtr<T> RCPtr<T>::Create(const_reference t) {
  RCPtr<T> p;
  return p.create(t);
}

template <typename T>
inline RCPtr<T> & RCPtr<T>::create(const_reference t) {
  release();
  thePointer = new T(t);
  //  increment();
  return *this;
}

template <typename T>
inline RCPtr<T> & RCPtr<T>::create() {
  release();
  thePointer = new T;
  //  increment();
  return *this;
}

template <typename T>
inline RCPtr<T> & RCPtr<T>::operator=(const RCPtr & p) {
  if ( thePointer == p.thePointer ) return *this;
  release();
  thePointer = p.thePointer;
  increment();
  return *this;
}

template <typename T>
template <typename UPtr>
inline RCPtr<T> & RCPtr<T>::operator=(const UPtr & u) {
  if ( thePointer == PtrTraits<UPtr>::barePointer(u) ) return *this;
  release();
  thePointer = PtrTraits<UPtr>::barePointer(u);
  increment();
  return *this;
}

template <typename T>
template <typename UPtr>
inline RCPtr<T> & RCPtr<T>::assignDynamic(const UPtr & u) {
  pointer up = dynamic_cast<pointer>(PtrTraits<UPtr>::barePointer(u));
  if ( thePointer == up ) return *this;
  release();
  thePointer = up;
  increment();
  return *this;
}

template <typename T>
template <typename UPtr>
inline RCPtr<T> & RCPtr<T>::assignConst(const UPtr & u) {
  pointer up = const_cast<pointer>(PtrTraits<UPtr>::barePointer(u));
  if ( thePointer == up ) return *this;
  release();
  thePointer = up;
  increment();
  return *this;
}

template <typename T>
inline void RCPtr<T>::swap(RCPtr & p) {
  ThePEG::swap(thePointer, p.thePointer);
}  

template <typename T>
inline bool RCPtr<T>::operator==(const RCPtr & p) const {
  return thePointer == p.thePointer;
}

template <typename T>
inline bool RCPtr<T>::operator==(const_pointer p) const {
  return thePointer == p;
}

template <typename T>
template <typename UPtr>
inline bool RCPtr<T>::operator==(const UPtr & u) const {
  return thePointer == PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool RCPtr<T>::operator!=(const RCPtr & p) const {
  return thePointer != p.thePointer;
}

template <typename T>
inline bool RCPtr<T>::operator!=(const_pointer p) const {
  return thePointer != p;
}

template <typename T>
template <typename UPtr>
inline bool RCPtr<T>::operator!=(const UPtr & u) const {
  return thePointer != PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool RCPtr<T>::operator<(const RCPtr & p) const {
  return thePointer < p.thePointer;
}

template <typename T>
inline bool RCPtr<T>::operator<(const_pointer p) const {
  return thePointer < p;
}

template <typename T>
inline bool RCPtr<T>::operator!() const {
  return !thePointer;
}

template <typename T>
inline RCPtr<T>::operator T * () const {
  return thePointer;
}

template <typename T>
inline typename RCPtr<T>::pointer RCPtr<T>::operator->() const {
  return thePointer;
}

template <typename T>
inline typename RCPtr<T>::reference RCPtr<T>::operator*() const {
  return *thePointer;
}

template <typename T>
inline void RCPtr<T>::release() {
  if ( RCPtrBase::release(thePointer) )  delete thePointer;
}

template <typename T>
inline void RCPtr<T>::increment() {
  RCPtrBase::increment(thePointer);
}
// ConstRCPtr

template <typename T>
inline ConstRCPtr<T>::ConstRCPtr()
  : thePointer(0) {}

template <typename T>
inline ConstRCPtr<T>::ConstRCPtr(const ConstRCPtr & p)
  : thePointer(p.thePointer) {
  increment();
}

template <typename T>
template <typename UPtr>
inline ConstRCPtr<T>::ConstRCPtr(const UPtr & u)
  : thePointer(PtrTraits<UPtr>::barePointer(u)) {
  increment();
}

template <typename T>
inline ConstRCPtr<T>::ConstRCPtr(const_pointer p)
  : thePointer(p) {
  increment();
}


template <typename T>
inline ConstRCPtr<T>::~ConstRCPtr(){
  release();
}

template <typename T>
inline ConstRCPtr<T> & ConstRCPtr<T>::
operator=(const ConstRCPtr & p) {
  if ( thePointer == p.thePointer ) return *this;
  release();
  thePointer = p.thePointer;
  increment();
  return *this;
}
  
template <typename T>
template <typename UPtr>
inline ConstRCPtr<T> & ConstRCPtr<T>::operator=(const UPtr & u) {
  if ( thePointer == PtrTraits<UPtr>::barePointer(u) ) return *this;
  release();
  thePointer = PtrTraits<UPtr>::barePointer(u);
  increment();
  return *this;
}

template <typename T>
template <typename UPtr>
inline ConstRCPtr<T> & ConstRCPtr<T>::
assignDynamic(const UPtr & u) {
  const_pointer up =
    dynamic_cast<const_pointer>(PtrTraits<UPtr>::barePointer(u));
  if ( thePointer == up ) return *this;
  release();
  thePointer = up;
  increment();
  return *this;
}

template <typename T>
inline void ConstRCPtr<T>::swap(ConstRCPtr & p) {
  ThePEG::swap(thePointer, p.thePointer);
}  

template <typename T>
inline bool ConstRCPtr<T>::operator==(const ConstRCPtr & p) const {
  return thePointer == p.thePointer;
}

template <typename T>
inline bool ConstRCPtr<T>::operator==(const_pointer p) const {
  return thePointer == p;
}

template <typename T>
template <typename UPtr>
inline bool ConstRCPtr<T>::operator==(const UPtr & u) const {
  return thePointer == PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool ConstRCPtr<T>::operator!=(const ConstRCPtr & p) const {
  return thePointer != p.thePointer;
}

template <typename T>
inline bool ConstRCPtr<T>::operator!=(const_pointer p) const {
  return thePointer != p;
}

template <typename T>
template <typename UPtr>
inline bool ConstRCPtr<T>::operator!=(const UPtr & u) const {
  return thePointer != PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool ConstRCPtr<T>::operator<(const ConstRCPtr & p) const {
  return thePointer < p.thePointer;
}

template <typename T>
inline bool ConstRCPtr<T>::operator<(const_pointer p) const {
  return thePointer < p;
}

template <typename T>
inline bool ConstRCPtr<T>::operator!() const {
  return !thePointer;
}

template <typename T>
inline ConstRCPtr<T>::operator const T * () const {
  return thePointer;
}

template <typename T>
inline typename ConstRCPtr<T>::const_pointer
ConstRCPtr<T>::operator->() const {
  return thePointer;
}

template <typename T>
inline typename ConstRCPtr<T>::const_reference
ConstRCPtr<T>::operator*() const {
  return *thePointer;
}

template <typename T>
inline void ConstRCPtr<T>::release() {
  if ( RCPtrBase::release(thePointer) ) delete thePointer;
}

template <typename T>
inline void ConstRCPtr<T>::increment() {
  RCPtrBase::increment(thePointer);
}

// TransientRCPtr

template <typename T>
inline TransientRCPtr<T>::TransientRCPtr()
  : thePointer(0) {}

template <typename T>
inline TransientRCPtr<T>::TransientRCPtr(const TransientRCPtr & p)
  : thePointer(p.thePointer) {
}

template <typename T>
template <typename UPtr>
inline TransientRCPtr<T>::TransientRCPtr(const UPtr & u)
  : thePointer(PtrTraits<UPtr>::barePointer(u)) {
}

template <typename T>
inline TransientRCPtr<T>::TransientRCPtr(pointer p)
  : thePointer(p) {}


template <typename T>
inline TransientRCPtr<T>::~TransientRCPtr(){
}

template <typename T>
inline TransientRCPtr<T> & TransientRCPtr<T>::
operator=(const TransientRCPtr & p) {
  thePointer = p.thePointer;
  return *this;
}
  
template <typename T>
template <typename UPtr>
inline TransientRCPtr<T> & TransientRCPtr<T>::
operator=(const UPtr & u) {
  thePointer = PtrTraits<UPtr>::barePointer(u);
  return *this;
}

template <typename T>
template <typename UPtr>
inline TransientRCPtr<T> & TransientRCPtr<T>::
assignDynamic(const UPtr & u) {
  thePointer = dynamic_cast<pointer>(PtrTraits<UPtr>::barePointer(u));
  return *this;
}

template <typename T>
template <typename UPtr>
inline TransientRCPtr<T> & TransientRCPtr<T>::
assignConst(const UPtr & u) {
  thePointer = const_cast<pointer>(PtrTraits<UPtr>::barePointer(u));
  return *this;
}

template <typename T>
inline bool TransientRCPtr<T>::
operator==(const TransientRCPtr & p) const {
  return thePointer == p.thePointer;
}

template <typename T>
inline bool TransientRCPtr<T>::operator==(const_pointer p) const {
  return thePointer == p;
}

template <typename T>
template <typename UPtr>
inline bool TransientRCPtr<T>::operator==(const UPtr & u) const {
  return thePointer == PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool TransientRCPtr<T>::
operator!=(const TransientRCPtr & p) const {
  return thePointer != p.thePointer;
}

template <typename T>
inline bool TransientRCPtr<T>::operator!=(const_pointer p) const {
  return thePointer != p;
}

template <typename T>
template <typename UPtr>
inline bool TransientRCPtr<T>::operator!=(const UPtr & u) const {
  return thePointer != PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool TransientRCPtr<T>::operator<(const TransientRCPtr & p) const {
  return thePointer < p.thePointer;
}

template <typename T>
inline bool TransientRCPtr<T>::operator<(const_pointer p) const {
  return thePointer < p;
}

template <typename T>
inline bool TransientRCPtr<T>::operator!() const {
  return !thePointer;
}

template <typename T>
inline TransientRCPtr<T>::operator T * () const {
  return thePointer;
}

template <typename T>
inline typename TransientRCPtr<T>::pointer
TransientRCPtr<T>::operator->() const {
  return thePointer;
}

template <typename T>
inline typename TransientRCPtr<T>::reference
TransientRCPtr<T>::operator*() const {
  return *thePointer;
}

// TransientConstRCPtr

template <typename T>
inline TransientConstRCPtr<T>::TransientConstRCPtr()
  : thePointer(0) {}

template <typename T>
inline TransientConstRCPtr<T>::
TransientConstRCPtr(const TransientConstRCPtr & p)
  : thePointer(p.thePointer) {}

template <typename T>
template <typename UPtr>
inline TransientConstRCPtr<T>::TransientConstRCPtr(const UPtr & u)
  : thePointer(PtrTraits<UPtr>::barePointer(u)) {}

template <typename T>
inline TransientConstRCPtr<T>::TransientConstRCPtr(const_pointer p)
  : thePointer(p) {}


template <typename T>
inline TransientConstRCPtr<T>::~TransientConstRCPtr() {}

template <typename T>
inline TransientConstRCPtr<T> & TransientConstRCPtr<T>::
operator=(const TransientConstRCPtr & p) {
  thePointer = p.thePointer;
  return *this;
}
  
template <typename T>
template <typename UPtr>
inline TransientConstRCPtr<T> & TransientConstRCPtr<T>::
operator=(const UPtr & u) {
  thePointer = PtrTraits<UPtr>::barePointer(u);
  return *this;
}

template <typename T>
template <typename UPtr>
inline TransientConstRCPtr<T> & TransientConstRCPtr<T>::
assignDynamic(const UPtr & u) {
  thePointer = dynamic_cast<const_pointer>(PtrTraits<UPtr>::barePointer(u));
  return *this;
}

template <typename T>
inline bool TransientConstRCPtr<T>::
operator==(const TransientConstRCPtr & p) const {
  return thePointer == p.thePointer;
}

template <typename T>
inline bool TransientConstRCPtr<T>::operator==(const_pointer p) const {
  return thePointer == p;
}

template <typename T>
template <typename UPtr>
inline bool TransientConstRCPtr<T>::operator==(const UPtr & u) const {
  return thePointer == PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool TransientConstRCPtr<T>::
operator!=(const TransientConstRCPtr & p) const {
  return thePointer != p.thePointer;
}

template <typename T>
inline bool TransientConstRCPtr<T>::operator!=(const_pointer p) const {
  return thePointer != p;
}

template <typename T>
template <typename UPtr>
inline bool TransientConstRCPtr<T>::operator!=(const UPtr & u) const {
  return thePointer != PtrTraits<UPtr>::barePointer(u);
}

template <typename T>
inline bool TransientConstRCPtr<T>::
operator<(const TransientConstRCPtr & p) const {
  return thePointer < p.thePointer;
}

template <typename T>
inline bool TransientConstRCPtr<T>::operator<(const_pointer p) const {
  return thePointer < p;
}

template <typename T>
inline bool TransientConstRCPtr<T>::operator!() const {
  return !thePointer;
}

template <typename T>
inline TransientConstRCPtr<T>::operator const T * () const {
  return thePointer;
}

template <typename T>
inline typename TransientConstRCPtr<T>::const_pointer
TransientConstRCPtr<T>::operator->() const {
  return thePointer;
}

template <typename T>
inline typename TransientConstRCPtr<T>::const_reference
TransientConstRCPtr<T>::operator*() const {
  return *thePointer;
}

}
}

template <typename T>
void std::swap(ThePEG::Pointer::RCPtr<T> & t1,
	       ThePEG::Pointer::RCPtr<T> & t2) {
  t1.swap(t2);
}

template <typename T>
void std::swap(ThePEG::Pointer::ConstRCPtr<T> & t1,
	       ThePEG::Pointer::ConstRCPtr<T> & t2) {
  t1.swap(t2);
}

