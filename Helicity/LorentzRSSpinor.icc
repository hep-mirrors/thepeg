// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzRSSpinor class.
//
// Author: Peter Richardson
//
#include "ThePEG/Helicity/HelicityDefinitions.h"

namespace ThePEG {
namespace Helicity {

// default zero constructor
template <typename Value> inline LorentzRSSpinor<Value>::LorentzRSSpinor(DiracRep d) {
  _dirac=d;
  _type=unknown_spinortype;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix){for(iy=0;iy<4;++iy){_spin[ix][iy]=complex<Value>();}}
}

template <typename Value> inline LorentzRSSpinor<Value>::LorentzRSSpinor(SpinorType s,DiracRep d) {
  _dirac=d;
  _type=s;
  for(int ix=0;ix<4;++ix){for(int iy=0;iy<4;++iy){_spin[ix][iy]==complex<Value>();}}
}

// constructor with complex numbers
template <typename Value> inline LorentzRSSpinor<Value>::
LorentzRSSpinor(complex<Value> a1, complex<Value> b1, complex<Value> c1, complex<Value> d1,
		complex<Value> a2, complex<Value> b2, complex<Value> c2, complex<Value> d2,
		complex<Value> a3, complex<Value> b3, complex<Value> c3, complex<Value> d3,
		complex<Value> a4, complex<Value> b4, complex<Value> c4, complex<Value> d4, DiracRep r) {
  _dirac=r;
  _type=unknown_spinortype;
  _spin[0][0]=a1;_spin[1][0]=a2;_spin[2][0]=a3;_spin[3][0]=a4;
  _spin[0][1]=b1;_spin[1][1]=b2;_spin[2][1]=b3;_spin[3][1]=b4;
  _spin[0][2]=c1;_spin[1][2]=c2;_spin[2][2]=c3;_spin[3][2]=c4;
  _spin[0][3]=d1;_spin[1][3]=d2;_spin[2][3]=d3;_spin[3][3]=d4;
}

template <typename Value> inline LorentzRSSpinor<Value>::
LorentzRSSpinor(complex<Value> a1, complex<Value> b1, complex<Value> c1, complex<Value> d1,
		complex<Value> a2, complex<Value> b2, complex<Value> c2, complex<Value> d2,
		complex<Value> a3, complex<Value> b3, complex<Value> c3, complex<Value> d3,
		complex<Value> a4, complex<Value> b4, complex<Value> c4, complex<Value> d4, 
		SpinorType s,DiracRep r) {
  _dirac=r;
  _type=s;
  _spin[0][0]=a1;_spin[1][0]=a2;_spin[2][0]=a3;_spin[3][0]=a4;
  _spin[0][1]=b1;_spin[1][1]=b2;_spin[2][1]=b3;_spin[3][1]=b4;
  _spin[0][2]=c1;_spin[1][2]=c2;_spin[2][2]=c3;_spin[3][2]=c4;
  _spin[0][3]=d1;_spin[1][3]=d2;_spin[2][3]=d3;_spin[3][3]=d4;
}

// subscript operator to return spinor components
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::operator()(int i,int j) const
{
  if ( i >= 0 && i <= 3 && j>=0 && j<=3) return _spin[i][j];
  throw HelicityLogicalError()
    << "Invalid component of LorentzRSSpinor requested. Component:" << i
    << " " << j << Exception::abortnow;
}

// set components by index
template <typename Value> inline complex<Value> & LorentzRSSpinor<Value>::operator () (int i,int j){
  if ( i >= 0 && i <= 3 && j>=0 && j<=3) return _spin[i][j];
  throw HelicityLogicalError()
    << "Invalid index " << i << " " << j << " called for LorentzRSSpinor."
    << Exception::abortnow;
}

// Get components
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::xs1() const {return _spin[0][0];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::xs2() const {return _spin[0][1];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::xs3() const {return _spin[0][2];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::xs4() const {return _spin[0][3];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::ys1() const {return _spin[1][0];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::ys2() const {return _spin[1][1];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::ys3() const {return _spin[1][2];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::ys4() const {return _spin[1][3];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::zs1() const {return _spin[2][0];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::zs2() const {return _spin[2][1];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::zs3() const {return _spin[2][2];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::zs4() const {return _spin[2][3];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::ts1() const {return _spin[3][0];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::ts2() const {return _spin[3][1];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::ts3() const {return _spin[3][2];}
template <typename Value> inline complex<Value> LorentzRSSpinor<Value>::ts4() const {return _spin[3][3];}

// Set components
template <typename Value> inline void LorentzRSSpinor<Value>::setXS1(complex<Value> in){_spin[0][0]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setXS2(complex<Value> in){_spin[0][1]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setXS3(complex<Value> in){_spin[0][2]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setXS4(complex<Value> in){_spin[0][3]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setYS1(complex<Value> in){_spin[1][0]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setYS2(complex<Value> in){_spin[1][1]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setYS3(complex<Value> in){_spin[1][2]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setYS4(complex<Value> in){_spin[1][3]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setZS1(complex<Value> in){_spin[2][0]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setZS2(complex<Value> in){_spin[2][1]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setZS3(complex<Value> in){_spin[2][2]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setZS4(complex<Value> in){_spin[2][3]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setTS1(complex<Value> in){_spin[3][0]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setTS2(complex<Value> in){_spin[3][1]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setTS3(complex<Value> in){_spin[3][2]=in;}
template <typename Value> inline void LorentzRSSpinor<Value>::setTS4(complex<Value> in){_spin[3][3]=in;}

// the equals operator
template <typename Value> inline LorentzRSSpinor<Value> & LorentzRSSpinor<Value>::operator = (const LorentzRSSpinor<Value> & in) {
  _dirac=in._dirac;
  _type=in._type;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix)
    {
      for(iy=0;iy<4;++iy)
	{
	  _spin[ix][iy]=in._spin[ix][iy];
	}
    }
  return *this;
}

// change the dirac matrix representation
template <typename Value> inline void LorentzRSSpinor<Value>::changeRep(DiracRep newdirac)
{if(newdirac!=_dirac) *this = transformRep(newdirac);}

// return the representation of the spinor
template <typename Value> inline DiracRep LorentzRSSpinor<Value>::Rep(){return _dirac;}

// return the type of the spinor
template <typename Value> inline SpinorType LorentzRSSpinor<Value>::Type(){return _type;}

// return the spinor in a different representation
template <typename Value> inline LorentzRSSpinor<Value> LorentzRSSpinor<Value>::transformRep(DiracRep newdirac) const
{
  // do nothing if all ready in the correct representation
  if(newdirac==_dirac){return LorentzRSSpinor<Value>(*this);}
  double fact(1./sqrt(2.));
  // transform from HELAS representation to Haber one
  complex<Value> out[4][4];unsigned int ix;
  if(newdirac==HELASDRep && _dirac==HaberDRep)
    {
      for(ix=0;ix<4;++ix)
	{
	  out[ix][0] =-fact*( _spin[ix][0]-_spin[ix][2]);
	  out[ix][1] =-fact*( _spin[ix][1]-_spin[ix][3]);
	  out[ix][2] =-fact*( _spin[ix][0]+_spin[ix][2]);
	  out[ix][3] =-fact*( _spin[ix][1]+_spin[ix][3]);
	}
    }
  // transform from Haber representation to HELAS one
  else if(newdirac==HaberDRep && _dirac==HELASDRep)
    {
      for(ix=0;ix<4;++ix)
	{
	  out[ix][0] =-fact*( _spin[ix][0]+_spin[ix][2]);
	  out[ix][1] =-fact*( _spin[ix][1]+_spin[ix][3]);
	  out[ix][2] =-fact*(-_spin[ix][0]+_spin[ix][2]);
	  out[ix][3] =-fact*(-_spin[ix][1]+_spin[ix][3]);
	}
    }
  // return the answer
  return LorentzRSSpinor<Value>(out[0][0],out[0][1],out[0][2],out[0][3],
			 out[1][0],out[1][1],out[1][2],out[1][3],
			 out[2][0],out[2][1],out[2][2],out[2][3],
			 out[3][0],out[3][1],out[3][2],out[3][3],_type,_dirac);
}

// dot product with a 4-vector or polarization vector
template <typename Value> inline LorentzSpinor<Value> LorentzRSSpinor<Value>::dot(const LorentzPolarizationVector & vec) const
{
  LorentzSpinor<Value> output(_type,_dirac);
  Complex temp;
  unsigned int ix;
  for(ix=0;ix<4;++ix)
    {
      temp=_spin[3][ix]*vec.t();
      temp-=_spin[0][ix]*vec.x();
      temp-=_spin[1][ix]*vec.y();
      temp-=_spin[2][ix]*vec.z();
      output[ix]=temp;
    }
  return output;
}
  
template <typename Value> 
inline LorentzSpinor<Value> 
LorentzRSSpinor<Value>::dot(const LorentzMomentum & invec) const
{
  LorentzSpinor<Value> output(_type,_dirac);
  complex<Value> temp;
  LorentzVector<double> vec = UnitRemoval::InvE * invec;
  unsigned int ix;
  for(ix=0;ix<4;++ix)
    {
      temp  = - ( _spin[0][ix]*vec.x() + _spin[1][ix]*vec.y()
		  + _spin[2][ix]*vec.z() ) +  _spin[3][ix]*vec.t();
      output[ix]=temp;
    }
  return output;
}

template <typename Value> 
template <typename ValueB>
inline complex<typename BinaryOpTraits<Value,ValueB>::MulT>
LorentzRSSpinor<Value>::generalScalar(LorentzRSSpinorBar<ValueB>& fbar,
				      Complex left, Complex right)
{
  complex<typename BinaryOpTraits<Value,ValueB>::MulT> output; 
  unsigned int iz;
  // ensure both spinors are in the same representation, otherwise change to default
  if(Rep()!=fbar.Rep())
    {
      fbar.changeRep(defaultDRep);
      changeRep(defaultDRep);
    }
  // low energy conventions
  if(Rep()==HaberDRep)
    {
      output=  left*( (fbar(3,0)-fbar(3,2))*(_spin[3][0]-_spin[3][2])
		     +(fbar(3,1)-fbar(3,3))*(_spin[3][1]-_spin[3][3]))
	     +right*( (fbar(3,0)+fbar(3,2))*(_spin[3][0]+_spin[3][2])
		     +(fbar(3,1)+fbar(3,3))*(_spin[3][1]+_spin[3][3]));
      for(iz=0;iz<3;++iz)
	{output-=
	    left*( (fbar(iz,0)-fbar(iz,2))*(_spin[iz][0]-_spin[iz][2])
		  +(fbar(iz,1)-fbar(iz,3))*(_spin[iz][1]-_spin[iz][3]))
	  +right*( (fbar(iz,0)+fbar(iz,2))*(_spin[iz][0]+_spin[iz][2])
		  +(fbar(iz,1)+fbar(iz,3))*(_spin[iz][1]+_spin[iz][3]));}
      output*=0.5;
    }
  // high energy conventions
  else
    {
      output = 
	  left*(fbar(3,0)*_spin[3][0]+fbar(3,1)*_spin[3][1])
	+right*(fbar(3,2)*_spin[3][2]+fbar(3,3)*_spin[3][3]);
      for(iz=0;iz<3;++iz)
	{output-=
	      left*(fbar(iz,0)*_spin[iz][0]+fbar(iz,1)*_spin[iz][1])
	    +right*(fbar(iz,2)*_spin[iz][2]+fbar(iz,3)*_spin[iz][3]);
	}
    }
  return output;
}

template <typename Value> 
template <typename ValueB>
inline LorentzVector<complex<
  typename BinaryOpTraits<Value,ValueB>::MulT> >
LorentzRSSpinor<Value>::generalCurrent(LorentzSpinorBar<ValueB>& fbar,
				       Complex left,
				       Complex right)
{
  typedef complex<typename BinaryOpTraits<Value,ValueB>::MulT> ResultT;
  ResultT output[4];
  // ensure both spinors are in the same representation, otherwise change to default
  if(Rep()!=fbar.Rep())
    {
      fbar.changeRep(defaultDRep);
      changeRep(defaultDRep);
    }
  unsigned int iz;
  // low energy
  if(Rep()==HaberDRep)
    {
      for(iz=0;iz<4;++iz)
	{output[iz] = 
	    0.5*left*( (fbar.s1()-fbar.s3())*(_spin[iz][0]-_spin[iz][2])
		      +(fbar.s2()-fbar.s4())*(_spin[iz][1]-_spin[iz][3]))
	    +0.5*right*( (fbar.s1()+fbar.s3())*(_spin[iz][0]+_spin[iz][2])
			+(fbar.s2()+fbar.s4())*(_spin[iz][1]+_spin[iz][3]));}
    }
  // high energy
  else
    {for(iz=0;iz<4;++iz)
	{output[iz]= left*(fbar.s1()*_spin[iz][0]+fbar.s2()*_spin[iz][1])
	    +right*(fbar.s3()*_spin[iz][2]+fbar.s4()*_spin[iz][3]);}}
  return LorentzVector<ResultT>(output[0],output[1],output[2],output[3]);
}
}
}
