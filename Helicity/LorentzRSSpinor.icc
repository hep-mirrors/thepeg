// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzRSSpinor class.
//
// Author: Peter Richardson
//
#include "ThePEG/Helicity/HelicityDefinitions.h"

namespace ThePEG {
namespace Helicity {

// default zero constructor
inline LorentzRSSpinor::LorentzRSSpinor(DiracRep d) {
  _dirac=d;
  _type=unknown_spinortype;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix){for(iy=0;iy<4;++iy){_spin[ix][iy]=0.0;}}
}

inline LorentzRSSpinor::LorentzRSSpinor(SpinorType s,DiracRep d) {
  _dirac=d;
  _type=s;
  for(int ix=0;ix<4;++ix){for(int iy=0;iy<4;++iy){_spin[ix][iy]=0.0;}}
}

// constructor with complex numbers
inline LorentzRSSpinor::
LorentzRSSpinor(Complex a1, Complex b1, Complex c1, Complex d1,
		Complex a2, Complex b2, Complex c2, Complex d2,
		Complex a3, Complex b3, Complex c3, Complex d3,
		Complex a4, Complex b4, Complex c4, Complex d4, DiracRep r) {
  _dirac=r;
  _type=unknown_spinortype;
  _spin[0][0]=a1;_spin[1][0]=a2;_spin[2][0]=a3;_spin[3][0]=a4;
  _spin[0][1]=b1;_spin[1][1]=b2;_spin[2][1]=b3;_spin[3][1]=b4;
  _spin[0][2]=c1;_spin[1][2]=c2;_spin[2][2]=c3;_spin[3][2]=c4;
  _spin[0][3]=d1;_spin[1][3]=d2;_spin[2][3]=d3;_spin[3][3]=d4;
}

inline LorentzRSSpinor::
LorentzRSSpinor(Complex a1, Complex b1, Complex c1, Complex d1,
		Complex a2, Complex b2, Complex c2, Complex d2,
		Complex a3, Complex b3, Complex c3, Complex d3,
		Complex a4, Complex b4, Complex c4, Complex d4, 
		SpinorType s,DiracRep r) {
  _dirac=r;
  _type=s;
  _spin[0][0]=a1;_spin[1][0]=a2;_spin[2][0]=a3;_spin[3][0]=a4;
  _spin[0][1]=b1;_spin[1][1]=b2;_spin[2][1]=b3;_spin[3][1]=b4;
  _spin[0][2]=c1;_spin[1][2]=c2;_spin[2][2]=c3;_spin[3][2]=c4;
  _spin[0][3]=d1;_spin[1][3]=d2;_spin[2][3]=d3;_spin[3][3]=d4;
}

// subscript operator to return spinor components
inline Complex LorentzRSSpinor::operator()(int i,int j) const
{
  if ( i >= 0 && i <= 3 && j>=0 && j<=3) return _spin[i][j];
  throw HelicityLogicalError()
    << "Invalid component of LorentzRSSpinor requested. Component:" << i
    << " " << j << Exception::abortnow;
}

// set components by index
inline Complex & LorentzRSSpinor::operator () (int i,int j){
  if ( i >= 0 && i <= 3 && j>=0 && j<=3) return _spin[i][j];
  throw HelicityLogicalError()
    << "Invalid index " << i << " " << j << " called for LorentzRSSpinor."
    << Exception::abortnow;
}

// Get components
inline Complex LorentzRSSpinor::xs1() const {return _spin[0][0];}
inline Complex LorentzRSSpinor::xs2() const {return _spin[0][1];}
inline Complex LorentzRSSpinor::xs3() const {return _spin[0][2];}
inline Complex LorentzRSSpinor::xs4() const {return _spin[0][3];}
inline Complex LorentzRSSpinor::ys1() const {return _spin[1][0];}
inline Complex LorentzRSSpinor::ys2() const {return _spin[1][1];}
inline Complex LorentzRSSpinor::ys3() const {return _spin[1][2];}
inline Complex LorentzRSSpinor::ys4() const {return _spin[1][3];}
inline Complex LorentzRSSpinor::zs1() const {return _spin[2][0];}
inline Complex LorentzRSSpinor::zs2() const {return _spin[2][1];}
inline Complex LorentzRSSpinor::zs3() const {return _spin[2][2];}
inline Complex LorentzRSSpinor::zs4() const {return _spin[2][3];}
inline Complex LorentzRSSpinor::ts1() const {return _spin[3][0];}
inline Complex LorentzRSSpinor::ts2() const {return _spin[3][1];}
inline Complex LorentzRSSpinor::ts3() const {return _spin[3][2];}
inline Complex LorentzRSSpinor::ts4() const {return _spin[3][3];}

// Set components
inline void LorentzRSSpinor::setXS1(Complex in){_spin[0][0]=in;}
inline void LorentzRSSpinor::setXS2(Complex in){_spin[0][1]=in;}
inline void LorentzRSSpinor::setXS3(Complex in){_spin[0][2]=in;}
inline void LorentzRSSpinor::setXS4(Complex in){_spin[0][3]=in;}
inline void LorentzRSSpinor::setYS1(Complex in){_spin[1][0]=in;}
inline void LorentzRSSpinor::setYS2(Complex in){_spin[1][1]=in;}
inline void LorentzRSSpinor::setYS3(Complex in){_spin[1][2]=in;}
inline void LorentzRSSpinor::setYS4(Complex in){_spin[1][3]=in;}
inline void LorentzRSSpinor::setZS1(Complex in){_spin[2][0]=in;}
inline void LorentzRSSpinor::setZS2(Complex in){_spin[2][1]=in;}
inline void LorentzRSSpinor::setZS3(Complex in){_spin[2][2]=in;}
inline void LorentzRSSpinor::setZS4(Complex in){_spin[2][3]=in;}
inline void LorentzRSSpinor::setTS1(Complex in){_spin[3][0]=in;}
inline void LorentzRSSpinor::setTS2(Complex in){_spin[3][1]=in;}
inline void LorentzRSSpinor::setTS3(Complex in){_spin[3][2]=in;}
inline void LorentzRSSpinor::setTS4(Complex in){_spin[3][3]=in;}

// the equals operator
inline LorentzRSSpinor & LorentzRSSpinor::operator = (const LorentzRSSpinor & in) {
  _dirac=in._dirac;
  _type=in._type;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix)
    {
      for(iy=0;iy<4;++iy)
	{
	  _spin[ix][iy]=in._spin[ix][iy];
	}
    }
  return *this;
}

// boost the spinor
inline LorentzRSSpinor LorentzRSSpinor::boost(double bx,double by,double bz) const
{
  // work out beta and chi
  double b2(bx*bx+by*by+bz*bz),beta(sqrt(b2)),chi(atanh(beta));
  double sinhchi(sinh(0.5*chi)/beta),coshchi(cosh(0.5*chi));
  double gamma = 1.0/sqrt(1.0-b2);
  double gmmone = b2 >0 ? (gamma-1.)/b2 : 0.0;
  double bvec[3]={bx,by,bz};
  unsigned int ix,iy,ixa,iya;
  // vector boost matrix
  double boostv[4][4];
  for(ix=0;ix<3;++ix)
    {
      for(iy=0;iy<3;++iy){boostv[ix][iy]=bvec[ix]*bvec[iy]*gmmone;}
      boostv[ix][ix]+=1;
      boostv[ix][3]=gamma*bvec[ix];
      boostv[3][ix]=boostv[ix][3];
    }
  boostv[3][3]=gamma;
  // spinor boost matrix
  Complex boosts[4][4],ii(0.,1.),nxminy(bx-ii*by),nxpiny(bx+ii*by);
  switch(_dirac)
    {
      // Haber lower energy
    case HaberDRep:
      boosts[0][0] = coshchi;
      boosts[0][1] = 0.;
      boosts[0][2] = sinhchi*bz;
      boosts[0][3] = sinhchi*nxminy;
      boosts[1][0] = 0.;
      boosts[1][1] = coshchi;
      boosts[1][2] = sinhchi*nxpiny;
      boosts[1][3] =-sinhchi*bz;
      boosts[2][0] = sinhchi*bz;
      boosts[2][1] = sinhchi*nxminy; 
      boosts[2][2] = coshchi; 
      boosts[2][3] = 0.; 
      boosts[3][0] = sinhchi*nxpiny;
      boosts[3][1] =-sinhchi*bz;
      boosts[3][2] = 0.;
      boosts[3][3] = coshchi;
      break;
      // HELAS
    case HELASDRep:
      boosts[0][0] = coshchi-sinhchi*bz;
      boosts[0][1] = -sinhchi*nxminy;
      boosts[0][2] = 0.;
      boosts[0][3] = 0.;
      boosts[1][0] = -sinhchi*nxpiny;
      boosts[1][1] = coshchi+sinhchi*bz;
      boosts[1][2] = 0.;
      boosts[1][3] = 0.;
      boosts[2][0] = 0.;
      boosts[2][1] = 0.;
      boosts[2][2] = coshchi+sinhchi*bz;
      boosts[2][3] = +sinhchi*nxminy;
      boosts[3][0] = 0.;
      boosts[3][1] = 0.;
      boosts[3][2] = +sinhchi*nxpiny;
      boosts[3][3] = coshchi-sinhchi*bz;
      break;
    }
  Complex out[4][4];
  // apply the boost
  for(ix=0;ix<4;++ix)
    {
      for(iy=0;iy<4;++iy)
	{
	  out[ix][iy]=0.;
	  for(ixa=0;ixa<4;++ixa)
	    {
	      for(iya=0;iya<4;++iya)
		{out[ix][iy]+=boostv[ix][ixa]*boosts[iy][iya]*_spin[ixa][iya];}
	    }
	}
    }
  return LorentzRSSpinor(out[0][0],out[0][1],out[0][2],out[0][3],
			 out[1][0],out[1][1],out[1][2],out[1][3],
			 out[2][0],out[2][1],out[2][2],out[2][3],
			 out[3][0],out[3][1],out[3][2],out[3][3],_type,_dirac);
}

// boost the spinor
inline LorentzRSSpinor LorentzRSSpinor::boost(const Hep3Vector & boostvec) const
{
  double beta = boostvec.mag(),b2=beta*beta;
  double bx=boostvec.x(),by=boostvec.y(),bz=boostvec.z();
  double gamma = 1.0/sqrt(1.0-b2);
  double gmmone = b2 >0 ? (gamma-1.)/b2 : 0.0;
  double chi = atanh(beta);
  double sinhchi = sinh(0.5*chi)/beta, coshchi = cosh(0.5*chi);
  Complex out[4][4],ii(0.,1.);
  Complex nxminy=bx-ii*by;
  Complex nxpiny=bx+ii*by;
  unsigned int ix,iy,ixa,iya;
  // vector boost matrix
  double boostv[4][4];
  for(ix=0;ix<3;++ix)
    {
      for(iy=0;iy<3;++iy){boostv[ix][iy]=boostvec[ix]*boostvec[iy]*gmmone;}
      boostv[ix][ix]+=1;
      boostv[ix][3]=gamma*boostvec[ix];
      boostv[3][ix]=boostv[ix][3];
    }
  boostv[3][3]=gamma;
  // spinor boost matrix
  Complex boosts[4][4];
  switch(_dirac)
    {
      // Haber lower energy
    case HaberDRep:
      boosts[0][0] = coshchi;
      boosts[0][1] = 0.;
      boosts[0][2] = sinhchi*bz;
      boosts[0][3] = sinhchi*nxminy;
      boosts[1][0] = 0.;
      boosts[1][1] = coshchi;
      boosts[1][2] = sinhchi*nxpiny;
      boosts[1][3] =-sinhchi*bz;
      boosts[2][0] = sinhchi*bz;
      boosts[2][1] = sinhchi*nxminy; 
      boosts[2][2] = coshchi; 
      boosts[2][3] = 0.; 
      boosts[3][0] = sinhchi*nxpiny;
      boosts[3][1] =-sinhchi*bz;
      boosts[3][2] = 0.;
      boosts[3][3] = coshchi;
      break;
      // HELAS
    case HELASDRep:
      boosts[0][0] = coshchi-sinhchi*bz;
      boosts[0][1] = -sinhchi*nxminy;
      boosts[0][2] = 0.;
      boosts[0][3] = 0.;
      boosts[1][0] = -sinhchi*nxpiny;
      boosts[1][1] = coshchi+sinhchi*bz;
      boosts[1][2] = 0.;
      boosts[1][3] = 0.;
      boosts[2][0] = 0.;
      boosts[2][1] = 0.;
      boosts[2][2] = coshchi+sinhchi*bz;
      boosts[2][3] = +sinhchi*nxminy;
      boosts[3][0] = 0.;
      boosts[3][1] = 0.;
      boosts[3][2] = +sinhchi*nxpiny;
      boosts[3][3] = coshchi-sinhchi*bz;
      break;
    }
  // apply the boost
  for(ix=0;ix<4;++ix)
    {
      for(iy=0;iy<4;++iy)
	{
	  out[ix][iy]=0.;
	  for(ixa=0;ixa<4;++ixa)
	    {
	      for(iya=0;iya<4;++iya)
		{out[ix][iy]+=boostv[ix][ixa]*boosts[iy][iya]*_spin[ixa][iya];}
	    }
	}
    }
  return LorentzRSSpinor(out[0][0],out[0][1],out[0][2],out[0][3],
			 out[1][0],out[1][1],out[1][2],out[1][3],
			 out[2][0],out[2][1],out[2][2],out[2][3],
			 out[3][0],out[3][1],out[3][2],out[3][3],_type,_dirac);

}

// change the dirac matrix representation
inline void LorentzRSSpinor::changeRep(DiracRep newdirac)
{if(newdirac!=_dirac) *this = transformRep(newdirac);}

// return the representation of the spinor
inline DiracRep LorentzRSSpinor::Rep(){return _dirac;}

// return the type of the spinor
inline SpinorType LorentzRSSpinor::Type(){return _type;}

// return the spinor in a different representation
inline LorentzRSSpinor LorentzRSSpinor::transformRep(DiracRep newdirac)
{
  // do nothing if all ready in the correct representation
  if(newdirac==_dirac){return *this;}
  double fact=1./sqrt(2.);
  // transform from HELAS representation to Haber one
  Complex out[4][4];unsigned int ix;
  if(newdirac==HELASDRep && _dirac==HaberDRep)
    {
      for(ix=0;ix<4;++ix)
	{
	  out[ix][0] =-fact*( _spin[ix][0]-_spin[ix][2]);
	  out[ix][1] =-fact*( _spin[ix][1]-_spin[ix][3]);
	  out[ix][2] =-fact*( _spin[ix][0]+_spin[ix][2]);
	  out[ix][3] =-fact*( _spin[ix][1]+_spin[ix][3]);
	}
    }
  // transform from Haber representation to HELAS one
  else if(newdirac==HaberDRep && _dirac==HELASDRep)
    {
      for(ix=0;ix<4;++ix)
	{
	  out[ix][0] =-fact*( _spin[ix][0]+_spin[ix][2]);
	  out[ix][1] =-fact*( _spin[ix][1]+_spin[ix][3]);
	  out[ix][2] =-fact*(-_spin[ix][0]+_spin[ix][2]);
	  out[ix][3] =-fact*(-_spin[ix][1]+_spin[ix][3]);
	}
    }
  // return the answer
  return LorentzRSSpinor(out[0][0],out[0][1],out[0][2],out[0][3],
			 out[1][0],out[1][1],out[1][2],out[1][3],
			 out[2][0],out[2][1],out[2][2],out[2][3],
			 out[3][0],out[3][1],out[3][2],out[3][3],_type,_dirac);
}

// dot product with a 4-vector or polarization vector
inline LorentzSpinor LorentzRSSpinor::dot(const LorentzPolarizationVector & vec) const
{
  LorentzSpinor output(_type,_dirac);
  Complex temp;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix)
    {
      temp=_spin[3][ix]*vec[3];
      for(iy=0;iy<3;++iy){temp-=_spin[iy][ix]*vec[iy];}
      output[ix]=temp;
    }
  return output;
}
  
inline LorentzSpinor LorentzRSSpinor::dot(const LorentzVector & vec) const
{
  LorentzSpinor output(_type,_dirac);
  Complex temp;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix)
    {
      temp=_spin[3][ix]*vec[3];
      for(iy=0;iy<3;++iy){temp-=_spin[iy][ix]*vec[iy];}
      output[ix]=temp;
    }
  return output;
}

}
}
