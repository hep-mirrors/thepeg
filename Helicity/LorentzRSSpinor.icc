// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzRSSpinor class.
//
// Author: Peter Richardson
//
#include "ThePEG/Helicity/HelicityDefinitions.h"

namespace ThePEG {
namespace Helicity {

// default zero constructor
inline LorentzRSSpinor::LorentzRSSpinor(DiracRep d) {
  _dirac=d;
  _type=unknown_spinortype;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix){for(iy=0;iy<4;++iy){_spin[ix][iy]=0.0;}}
}

inline LorentzRSSpinor::LorentzRSSpinor(SpinorType s,DiracRep d) {
  _dirac=d;
  _type=s;
  for(int ix=0;ix<4;++ix){for(int iy=0;iy<4;++iy){_spin[ix][iy]=0.0;}}
}

// constructor with complex numbers
inline LorentzRSSpinor::
LorentzRSSpinor(Complex a1, Complex b1, Complex c1, Complex d1,
		Complex a2, Complex b2, Complex c2, Complex d2,
		Complex a3, Complex b3, Complex c3, Complex d3,
		Complex a4, Complex b4, Complex c4, Complex d4, DiracRep r) {
  _dirac=r;
  _type=unknown_spinortype;
  _spin[0][0]=a1;_spin[1][0]=a2;_spin[2][0]=a3;_spin[3][0]=a4;
  _spin[0][1]=b1;_spin[1][1]=b2;_spin[2][1]=b3;_spin[3][1]=b4;
  _spin[0][2]=c1;_spin[1][2]=c2;_spin[2][2]=c3;_spin[3][2]=c4;
  _spin[0][3]=d1;_spin[1][3]=d2;_spin[2][3]=d3;_spin[3][3]=d4;
}

inline LorentzRSSpinor::
LorentzRSSpinor(Complex a1, Complex b1, Complex c1, Complex d1,
		Complex a2, Complex b2, Complex c2, Complex d2,
		Complex a3, Complex b3, Complex c3, Complex d3,
		Complex a4, Complex b4, Complex c4, Complex d4, 
		SpinorType s,DiracRep r) {
  _dirac=r;
  _type=s;
  _spin[0][0]=a1;_spin[1][0]=a2;_spin[2][0]=a3;_spin[3][0]=a4;
  _spin[0][1]=b1;_spin[1][1]=b2;_spin[2][1]=b3;_spin[3][1]=b4;
  _spin[0][2]=c1;_spin[1][2]=c2;_spin[2][2]=c3;_spin[3][2]=c4;
  _spin[0][3]=d1;_spin[1][3]=d2;_spin[2][3]=d3;_spin[3][3]=d4;
}

// subscript operator to return spinor components
inline Complex LorentzRSSpinor::operator()(int i,int j) const
{
  if ( i >= 0 && i <= 3 && j>=0 && j<=3) return _spin[i][j];
  throw HelicityLogicalError()
    << "Invalid component of LorentzRSSpinor requested. Component:" << i
    << " " << j << Exception::abortnow;
}

// set components by index
inline Complex & LorentzRSSpinor::operator () (int i,int j){
  if ( i >= 0 && i <= 3 && j>=0 && j<=3) return _spin[i][j];
  throw HelicityLogicalError()
    << "Invalid index " << i << " " << j << " called for LorentzRSSpinor."
    << Exception::abortnow;
}

// Get components
inline Complex LorentzRSSpinor::xs1() const {return _spin[0][0];}
inline Complex LorentzRSSpinor::xs2() const {return _spin[0][1];}
inline Complex LorentzRSSpinor::xs3() const {return _spin[0][2];}
inline Complex LorentzRSSpinor::xs4() const {return _spin[0][3];}
inline Complex LorentzRSSpinor::ys1() const {return _spin[1][0];}
inline Complex LorentzRSSpinor::ys2() const {return _spin[1][1];}
inline Complex LorentzRSSpinor::ys3() const {return _spin[1][2];}
inline Complex LorentzRSSpinor::ys4() const {return _spin[1][3];}
inline Complex LorentzRSSpinor::zs1() const {return _spin[2][0];}
inline Complex LorentzRSSpinor::zs2() const {return _spin[2][1];}
inline Complex LorentzRSSpinor::zs3() const {return _spin[2][2];}
inline Complex LorentzRSSpinor::zs4() const {return _spin[2][3];}
inline Complex LorentzRSSpinor::ts1() const {return _spin[3][0];}
inline Complex LorentzRSSpinor::ts2() const {return _spin[3][1];}
inline Complex LorentzRSSpinor::ts3() const {return _spin[3][2];}
inline Complex LorentzRSSpinor::ts4() const {return _spin[3][3];}

// Set components
inline void LorentzRSSpinor::setXS1(Complex in){_spin[0][0]=in;}
inline void LorentzRSSpinor::setXS2(Complex in){_spin[0][1]=in;}
inline void LorentzRSSpinor::setXS3(Complex in){_spin[0][2]=in;}
inline void LorentzRSSpinor::setXS4(Complex in){_spin[0][3]=in;}
inline void LorentzRSSpinor::setYS1(Complex in){_spin[1][0]=in;}
inline void LorentzRSSpinor::setYS2(Complex in){_spin[1][1]=in;}
inline void LorentzRSSpinor::setYS3(Complex in){_spin[1][2]=in;}
inline void LorentzRSSpinor::setYS4(Complex in){_spin[1][3]=in;}
inline void LorentzRSSpinor::setZS1(Complex in){_spin[2][0]=in;}
inline void LorentzRSSpinor::setZS2(Complex in){_spin[2][1]=in;}
inline void LorentzRSSpinor::setZS3(Complex in){_spin[2][2]=in;}
inline void LorentzRSSpinor::setZS4(Complex in){_spin[2][3]=in;}
inline void LorentzRSSpinor::setTS1(Complex in){_spin[3][0]=in;}
inline void LorentzRSSpinor::setTS2(Complex in){_spin[3][1]=in;}
inline void LorentzRSSpinor::setTS3(Complex in){_spin[3][2]=in;}
inline void LorentzRSSpinor::setTS4(Complex in){_spin[3][3]=in;}

// the equals operator
inline LorentzRSSpinor & LorentzRSSpinor::operator = (const LorentzRSSpinor & in) {
  _dirac=in._dirac;
  _type=in._type;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix)
    {
      for(iy=0;iy<4;++iy)
	{
	  _spin[ix][iy]=in._spin[ix][iy];
	}
    }
  return *this;
}

// change the dirac matrix representation
inline void LorentzRSSpinor::changeRep(DiracRep newdirac)
{if(newdirac!=_dirac) *this = transformRep(newdirac);}

// return the representation of the spinor
inline DiracRep LorentzRSSpinor::Rep(){return _dirac;}

// return the type of the spinor
inline SpinorType LorentzRSSpinor::Type(){return _type;}

// return the spinor in a different representation
inline LorentzRSSpinor LorentzRSSpinor::transformRep(DiracRep newdirac) const
{
  // do nothing if all ready in the correct representation
  if(newdirac==_dirac){return LorentzRSSpinor(*this);}
  double fact(1./sqrt(2.));
  // transform from HELAS representation to Haber one
  Complex out[4][4];unsigned int ix;
  if(newdirac==HELASDRep && _dirac==HaberDRep)
    {
      for(ix=0;ix<4;++ix)
	{
	  out[ix][0] =-fact*( _spin[ix][0]-_spin[ix][2]);
	  out[ix][1] =-fact*( _spin[ix][1]-_spin[ix][3]);
	  out[ix][2] =-fact*( _spin[ix][0]+_spin[ix][2]);
	  out[ix][3] =-fact*( _spin[ix][1]+_spin[ix][3]);
	}
    }
  // transform from Haber representation to HELAS one
  else if(newdirac==HaberDRep && _dirac==HELASDRep)
    {
      for(ix=0;ix<4;++ix)
	{
	  out[ix][0] =-fact*( _spin[ix][0]+_spin[ix][2]);
	  out[ix][1] =-fact*( _spin[ix][1]+_spin[ix][3]);
	  out[ix][2] =-fact*(-_spin[ix][0]+_spin[ix][2]);
	  out[ix][3] =-fact*(-_spin[ix][1]+_spin[ix][3]);
	}
    }
  // return the answer
  return LorentzRSSpinor(out[0][0],out[0][1],out[0][2],out[0][3],
			 out[1][0],out[1][1],out[1][2],out[1][3],
			 out[2][0],out[2][1],out[2][2],out[2][3],
			 out[3][0],out[3][1],out[3][2],out[3][3],_type,_dirac);
}

// dot product with a 4-vector or polarization vector
inline LorentzSpinor LorentzRSSpinor::dot(const LorentzPolarizationVector & vec) const
{
  LorentzSpinor output(_type,_dirac);
  Complex temp;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix)
    {
      temp=_spin[3][ix]*vec[3];
      for(iy=0;iy<3;++iy){temp-=_spin[iy][ix]*vec[iy];}
      output[ix]=temp;
    }
  return output;
}
  
inline LorentzSpinor LorentzRSSpinor::dot(const LorentzVector & vec) const
{
  LorentzSpinor output(_type,_dirac);
  Complex temp;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix)
    {
      temp=_spin[3][ix]*vec[3];
      for(iy=0;iy<3;++iy){temp-=_spin[iy][ix]*vec[iy];}
      output[ix]=temp;
    }
  return output;
}

inline Complex LorentzRSSpinor::generalScalar(LorentzRSSpinorBar& fbar,Complex left,
					      Complex right)
{
  Complex output; 
  unsigned int iz;
  // ensure both spinors are in the same representation, otherwise change to default
  if(Rep()!=fbar.Rep())
    {
      fbar.changeRep(defaultDRep);
      changeRep(defaultDRep);
    }
  // low energy conventions
  if(Rep()==HaberDRep)
    {
      output=  left*( (fbar(3,0)-fbar(3,2))*(_spin[3][0]-_spin[3][2])
		     +(fbar(3,1)-fbar(3,3))*(_spin[3][1]-_spin[3][3]))
	     +right*( (fbar(3,0)+fbar(3,2))*(_spin[3][0]+_spin[3][2])
		     +(fbar(3,1)+fbar(3,3))*(_spin[3][1]+_spin[3][3]));
      for(iz=0;iz<3;++iz)
	{output-=
	    left*( (fbar(iz,0)-fbar(iz,2))*(_spin[iz][0]-_spin[iz][2])
		  +(fbar(iz,1)-fbar(iz,3))*(_spin[iz][1]-_spin[iz][3]))
	  +right*( (fbar(iz,0)+fbar(iz,2))*(_spin[iz][0]+_spin[iz][2])
		  +(fbar(iz,1)+fbar(iz,3))*(_spin[iz][1]+_spin[iz][3]));}
      output*=0.5;
    }
  // high energy conventions
  else
    {
      output = 
	  left*(fbar(3,0)*_spin[3][0]+fbar(3,1)*_spin[3][1])
	+right*(fbar(3,2)*_spin[3][2]+fbar(3,3)*_spin[3][3]);
      for(iz=0;iz<3;++iz)
	{output-=
	      left*(fbar(iz,0)*_spin[iz][0]+fbar(iz,1)*_spin[iz][1])
	    +right*(fbar(iz,2)*_spin[iz][2]+fbar(iz,3)*_spin[iz][3]);
	}
    }
  return output;
}

inline LorentzPolarizationVector LorentzRSSpinor::generalCurrent(LorentzSpinorBar& fbar,
								 Complex left,
								 Complex right)
{
  LorentzPolarizationVector output;
  // ensure both spinors are in the same representation, otherwise change to default
  if(Rep()!=fbar.Rep())
    {
      fbar.changeRep(defaultDRep);
      changeRep(defaultDRep);
    }
  unsigned int iz;
  // low energy
  if(Rep()==HaberDRep)
    {
      for(iz=0;iz<4;++iz)
	{output[iz] = 
	    0.5*left*( (fbar.s1()-fbar.s3())*(_spin[iz][0]-_spin[iz][2])
		      +(fbar.s2()-fbar.s4())*(_spin[iz][1]-_spin[iz][3]))
	    +0.5*right*( (fbar.s1()+fbar.s3())*(_spin[iz][0]+_spin[iz][2])
			+(fbar.s2()+fbar.s4())*(_spin[iz][1]+_spin[iz][3]));}
    }
  // high energy
  else
    {for(iz=0;iz<4;++iz)
	{output[iz]= left*(fbar.s1()*_spin[iz][0]+fbar.s2()*_spin[iz][1])
	    +right*(fbar.s3()*_spin[iz][2]+fbar.s4()*_spin[iz][3]);}}
  return output;
}
}
}
