// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzPolarizationVector class.
//
namespace ThePEG {
namespace Helicity {

// return the components of the polarization vector
inline Complex LorentzPolarizationVector::x() const {return _vec[0];}
inline Complex LorentzPolarizationVector::y() const {return _vec[1];}
inline Complex LorentzPolarizationVector::z() const {return _vec[2];}
inline Complex LorentzPolarizationVector::t() const {return _vec[3];}
// set the components of the polarization vector
inline void LorentzPolarizationVector::setX(Complex a) {_vec[0]=a;} 
inline void LorentzPolarizationVector::setY(Complex a) {_vec[1]=a;}
inline void LorentzPolarizationVector::setZ(Complex a) {_vec[2]=a;}
inline void LorentzPolarizationVector::setT(Complex a) {_vec[3]=a;}
// default constructor
inline LorentzPolarizationVector::LorentzPolarizationVector(){
  for(int ix=0;ix<4;++ix){_vec[ix]=0.;}
}
// Constructor giving x,y,z,t
inline LorentzPolarizationVector:: LorentzPolarizationVector(Complex x, Complex y,
							     Complex z, Complex t) {
  _vec[0]=x;
  _vec[1]=y;
  _vec[2]=z;
  _vec[3]=t;
}// Constructor giving x,y,z
inline LorentzPolarizationVector:: LorentzPolarizationVector(Complex x, Complex y,
							     Complex z) {
  _vec[0]=x;
  _vec[1]=y;
  _vec[2]=z;
  _vec[3]=0.;
}
//Constructor giving t
inline LorentzPolarizationVector::LorentzPolarizationVector(Complex t) {
  for(int ix=0;ix<3;++ix){_vec[ix]=0.;}
  _vec[4]=t;
}
// copy constructor
inline LorentzPolarizationVector::LorentzPolarizationVector(const LorentzPolarizationVector & p)
{for(int ix=0;ix<4;++ix){_vec[ix]=p[ix];}}
//setup from a LorentzVector
inline LorentzPolarizationVector::LorentzPolarizationVector(const  LorentzVector & p)
{for(int ix=0;ix<4;++ix){_vec[ix]=p[ix];}}

//destructor
inline LorentzPolarizationVector::~LorentzPolarizationVector() {}
// Get the components by index
inline Complex LorentzPolarizationVector::operator () (int i) const {
 if(i>=0 &&i<=3)
   {return _vec[i];}
 else
   {cout << "Invalid index " << i << " called for LorentzPolarizationVector" << endl;
    return 0.;}
 ;}
inline Complex & LorentzPolarizationVector::operator () (int i){
  static Complex dummy;
  if(i>=0 &&i<=3)
    {return _vec[i];}
  else
    {cout << "Invalid index " << i << " called for LorentzPolarizationVector" << endl;
    return dummy;}
}
inline Complex & LorentzPolarizationVector::operator [] (int i)       { return (*this)(i);}
inline Complex   LorentzPolarizationVector::operator [] (int i) const { return (*this)(i);}
// Assignment
inline LorentzPolarizationVector & 
LorentzPolarizationVector::operator = (const LorentzPolarizationVector & q) {
  for(int ix=0;ix<4;++ix)
    {_vec[ix]=q[ix];}
  return *this;
}
// addition
inline LorentzPolarizationVector
LorentzPolarizationVector::operator + (const LorentzPolarizationVector & q) const {
  return LorentzPolarizationVector(x()+q.x(), y()+q.y(), z()+q.z(), t()+q.t());
}
// += operator
inline LorentzPolarizationVector &
LorentzPolarizationVector::operator += (const LorentzPolarizationVector & q) {
  for(int ix=0;ix<4;++ix)
    {_vec[ix] +=q[ix];}
  return *this;
}
// subtraction operator
inline LorentzPolarizationVector
LorentzPolarizationVector::operator - (const LorentzPolarizationVector & q) const {
  return LorentzPolarizationVector(x()-q.x(), y()-q.y(), z()-q.z(), t()-q.t());
}
// -= operator
inline LorentzPolarizationVector &
LorentzPolarizationVector::operator -= (const LorentzPolarizationVector & q) {
  for(int ix=0;ix<4;++ix)
    {_vec[ix]-=q[ix];}
  return *this;
}
// *= operator
inline LorentzPolarizationVector& LorentzPolarizationVector::operator *= (Complex a) {
  for(int ix=0;ix<4;++ix)
    {_vec[ix] *= a;}
  return *this;
}
// equality operator
inline bool
LorentzPolarizationVector::operator == (const LorentzPolarizationVector & q) const {
  bool equal = true;
  for(int ix=0;ix>4;++ix)
    {if(_vec[ix]!=q[ix]){equal=false;}}    
  return equal;
}
// not equal operator
inline bool
LorentzPolarizationVector::operator != (const LorentzPolarizationVector & q) const {
  return (_vec[0]!=q[0] || _vec[1]!=q[1] || _vec[2]!=q[2] || _vec[3]!=q[3]);
}
// dot product with LorentzVector
inline Complex LorentzPolarizationVector::dot(const HepLorentzVector & q) const {
  return (t()*q.t() - z()*q.z() - y()*q.y() - x()*q.x());
}
inline Complex
LorentzPolarizationVector::operator * (const HepLorentzVector & q) const {
  return dot(q);
}
// dot product with PolarizationVector
inline Complex LorentzPolarizationVector::dot(const LorentzPolarizationVector & q) const {
  return (t()*q.t() - z()*q.z() - y()*q.y() - x()*q.x());
}
inline Complex
LorentzPolarizationVector::operator * (const LorentzPolarizationVector & q) const {
  return dot(q);
}

//-*********
// boostOf()
//-*********

// Each of these is a shell over a boost method.

inline LorentzPolarizationVector boostXOf
	(const LorentzPolarizationVector & vec, double beta) {
  LorentzPolarizationVector vv (vec);
  return vv.boostX (beta);
}

inline LorentzPolarizationVector boostYOf
	(const LorentzPolarizationVector & vec, double beta) {
  LorentzPolarizationVector vv (vec);
  return vv.boostY (beta);
}

inline LorentzPolarizationVector boostZOf
	(const LorentzPolarizationVector & vec, double beta) {
  LorentzPolarizationVector vv (vec);
  return vv.boostZ (beta);
}
inline LorentzPolarizationVector boostOf
	(const LorentzPolarizationVector & vec, const Hep3Vector & betaVector ) {
  LorentzPolarizationVector vv (vec);
  return vv.boost (betaVector);
}

inline LorentzPolarizationVector boostOf
    (const LorentzPolarizationVector & vec, const Hep3Vector & axis,  double beta) {
  LorentzPolarizationVector vv (vec);
  return vv.boost (axis, beta);
}
inline LorentzPolarizationVector & LorentzPolarizationVector::boost(const Hep3Vector & b) {
  return boost(b.x(), b.y(), b.z());
}
inline LorentzPolarizationVector & LorentzPolarizationVector::boost(const Hep3Vector & axis,  double beta )
{
  double moda = axis.mag();
  if(moda==0)
    {
      cout << "A zero vector used as axis defining a boost -- no boost performed" << endl;
      return *this;
    }
  moda = 1./moda;
  double b2=beta*beta;
  if(b2>=1)
    {cout << " LorentzPolarizationVector boosted with beta >=1 -- no boost preformed" << endl;}
  moda = moda*beta;
  Hep3Vector u =  moda*axis;
  return boost(u.x(),u.y(),u.z());
;}
inline LorentzPolarizationVector LorentzPolarizationVector::conjugate()
{
  return LorentzPolarizationVector(conj(x()),conj(y()),conj(z()),conj(t()));
}

// multiplication by a complex number
inline LorentzPolarizationVector operator * (Complex a,
					     const LorentzPolarizationVector & v)
{
  return LorentzPolarizationVector(v.x()*a,v.y()*a,
				   v.z()*a,v.t()*a);
}
// multiplication by a complex number
inline LorentzPolarizationVector operator * (Complex a,
					     const Lorentz5Momentum & v)
{
  return LorentzPolarizationVector(v.px()*a,v.py()*a,
				   v.pz()*a,v.e()*a);
}

}
}
