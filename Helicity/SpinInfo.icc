// -*- C++ -*-
//
// SpinInfo.icc is a part of ThePEG - Toolkit for HEP Event Generation
// Copyright (C) 2003-2007 Peter Richardson, Leif Lonnblad
//
// ThePEG is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the SpinInfo class.
//
// Author: Peter Richardson
//

namespace ThePEG {
namespace Helicity {

inline SpinInfo::SpinInfo()
  : _prodloc(-1), _decayloc(-1), _decayed(false), _developed(false) {}

inline SpinInfo::SpinInfo(const Lorentz5Momentum & in, bool intim)
  :  _timelike(intim),_decayed(false), _developed(false),
     _productionmomentum(in),_currentmomentum(in) {}

inline SpinInfo::SpinInfo(const SpinInfo & x)
  : SpinBase(x), _production(x._production), _decay(x._decay),
    _timelike(x._timelike),
    _prodloc(x._prodloc), _decayloc(x._decayloc),
    _decayed(x._decayed), _developed(x._developed),_rhomatrix(x._rhomatrix),
    _Dmatrix(x._Dmatrix),_spin(x._spin),
    _productionmomentum(x._productionmomentum),
    _decaymomentum(x._decaymomentum),
    _currentmomentum(x._currentmomentum) {
  x._production=VertexPtr();
  x._decay=VertexPtr();
  // set the vertex so it now points to the copy
  if(_production) {
    // for timelike
    if(_timelike) _production->resetOutgoing(this,_prodloc); 
    // for spacelike
    else          _production->resetIncoming(this,_prodloc);
  }
}

inline EIPtr SpinInfo::clone() const {
  tcSpinPtr temp=this;
  return const_ptr_cast<SpinPtr>(temp);
}

inline void SpinInfo::rebind(const EventTranslationMap & trans) {
  if(_production) _production = trans.translate(_production);
  if(_decay)      _decay      = trans.translate(_decay);
  SpinBase::rebind(trans);
}

// set and get methods for the vertex
inline void SpinInfo::setProductionVertex(VertexPtr in) const {
  _production=in;
  // add to the list of outgoing if timelike
  int temp;
  if(_timelike) in->addOutgoing(this,temp); 
  // or incoming if spacelike
  else          in->addIncoming(this,temp);
  _prodloc=temp;
}

// set the vertex at which the particle was produced
inline tcVertexPtr SpinInfo::getProductionVertex() const {
  return _production;
}

// get the vertex at which the particle was produced
inline void SpinInfo::setDecayVertex(VertexPtr in) const {
  _decay=in;
  int temp;
  in->addIncoming(this,temp);
  _decayloc=temp;
  if(temp!=0){cout << "something dodgy here can only decay once" << endl;}
}

// get the vertex at which the particle decayed or branched
inline tcVertexPtr SpinInfo::getDecayVertex() const {
  return _decay;
}

// get decay for particle
inline bool SpinInfo::decayed() const {
  return _decayed;
}

// get developed for the particle
inline bool SpinInfo::developed() const {
  return _developed;
}

inline void SpinInfo::decay() const {
  // if the particle has already been decayed do nothing
  if(_decayed) return;
  // otherwise we need to obtain the correct rho matrix
  _decayed=true;
  if(_production) _rhomatrix = _production->getRhoMatrix(_prodloc);
  _decaymomentum = _currentmomentum;
}

inline void SpinInfo::develop() const {
  // if the particle has already been developed do nothing
  if(_developed) return; 
  // otherwise we need to obtain the correct D matrix
  _developed=true;
  if(_decay) _Dmatrix= _decay->getDMatrix(_decayloc);
  else {
    _Dmatrix=RhoDMatrix(iSpin());
    _Dmatrix.average();
  }
}

// set the decayed variable for the particle
inline void SpinInfo::setDeveloped(bool in) const {
  _developed=in;
}

// get the developed variable for the particle
// access to the rho matrix
inline RhoDMatrix SpinInfo::rhoMatrix() const {
  return _rhomatrix;
}

inline RhoDMatrix & SpinInfo::rhoMatrix() {
  return _rhomatrix;
}

// access to the D matrix
inline RhoDMatrix SpinInfo::DMatrix() const {
  return _Dmatrix;
}

inline RhoDMatrix & SpinInfo::DMatrix() {
  return _Dmatrix;
}

// return 2s+1 for the particle
inline PDT::Spin SpinInfo::iSpin() const {
  return _spin;
}

// set the spin of the particle
  inline PDT::Spin SpinInfo::iSpin(PDT::Spin in) {
  _spin=in;
  _rhomatrix.iSpin(_spin);
  _rhomatrix.average();
  _Dmatrix.iSpin(_spin);
  _Dmatrix.average();
  return _spin;
}

inline const Lorentz5Momentum & SpinInfo::productionMomentum() const {
  return _productionmomentum;
}
 
inline const Lorentz5Momentum & SpinInfo::currentMomentum() const {
  return _currentmomentum;
}

inline void SpinInfo::setProductionMomentum(const Lorentz5Momentum & in) {
  _productionmomentum=in;
  _currentmomentum=in;
}

inline void SpinInfo::setTimelike(bool in) {
  _timelike=in;
}

inline bool SpinInfo::timelike() {
  return _timelike;
}

inline void SpinInfo::decayed(bool in) const {
  _decayed=in;
}

inline bool SpinInfo::isNear(const Lorentz5Momentum & p) {
  return currentMomentum().isNear(p,_eps);
}

}

}

