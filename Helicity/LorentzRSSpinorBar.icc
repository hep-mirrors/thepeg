
// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzRSSpinorBar class.
//
// Author: Peter Richardson
//

namespace ThePEG {
namespace Helicity {

// inlined function of the LorentzRSSpinorBar class
// default zero constructor
inline LorentzRSSpinorBar::LorentzRSSpinorBar(DiracRep dirac) {
  _dirac=dirac;
  _type=unknown_spinortype;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix){for(iy=0;iy<4;++iy){_spin[ix][iy]=0.;}}
}

inline LorentzRSSpinorBar::LorentzRSSpinorBar(SpinorType type, DiracRep dirac) {
  _dirac=dirac;
  _type=type;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix){for(iy=0;iy<4;++iy){_spin[ix][iy]=0.;}}
}

// constructor with complex numbers
inline LorentzRSSpinorBar::
LorentzRSSpinorBar(Complex a1,Complex b1, Complex c1,Complex d1,
		   Complex a2,Complex b2, Complex c2,Complex d2,
		   Complex a3,Complex b3, Complex c3,Complex d3,
		   Complex a4,Complex b4, Complex c4,Complex d4,DiracRep dirac) {
  _dirac=dirac;
  _type=unknown_spinortype;
  _spin[0][0]=a1;_spin[1][0]=a2;_spin[2][0]=a3;_spin[3][0]=a4;
  _spin[0][1]=b1;_spin[1][1]=b2;_spin[2][1]=b3;_spin[3][1]=b4;
  _spin[0][2]=c1;_spin[1][2]=c2;_spin[2][2]=c3;_spin[3][2]=c4;
  _spin[0][3]=d1;_spin[1][3]=d2;_spin[2][3]=d3;_spin[3][3]=d4;
}

inline LorentzRSSpinorBar::
LorentzRSSpinorBar(Complex a1,Complex b1, Complex c1,Complex d1,
		   Complex a2,Complex b2, Complex c2,Complex d2,
		   Complex a3,Complex b3, Complex c3,Complex d3,
		   Complex a4,Complex b4, Complex c4,Complex d4,SpinorType type,
		   DiracRep dirac) {
  _dirac=dirac;
  _type=type;
  _spin[0][0]=a1;_spin[1][0]=a2;_spin[2][0]=a3;_spin[3][0]=a4;
  _spin[0][1]=b1;_spin[1][1]=b2;_spin[2][1]=b3;_spin[3][1]=b4;
  _spin[0][2]=c1;_spin[1][2]=c2;_spin[2][2]=c3;_spin[3][2]=c4;
  _spin[0][3]=d1;_spin[1][3]=d2;_spin[2][3]=d3;_spin[3][3]=d4;
}

  inline Complex LorentzRSSpinorBar::operator()(int i,int j) const
{
  if ( i >= 0 && i <= 3 && j>=0 && j<=3) return _spin[i][j];
  else throw HelicityLogicalError()
    << "Invalid component of LorentzRSSpinorBar Requested. Component:" << i << " " << j
    << Exception::abortnow;
}

// set components by index
  inline Complex & LorentzRSSpinorBar::operator () (int i,int j){
  if ( i>= 0 && i <= 3 && j>=0 && j<=3) return _spin[i][j];
  throw HelicityLogicalError()
    << "Invalid index " << i << " " << j << " called for LorentzRSSpinorBar."
    << Exception::abortnow;
}

// Get components
inline Complex LorentzRSSpinorBar::xs1() const {return _spin[0][0];}
inline Complex LorentzRSSpinorBar::xs2() const {return _spin[0][1];}
inline Complex LorentzRSSpinorBar::xs3() const {return _spin[0][2];}
inline Complex LorentzRSSpinorBar::xs4() const {return _spin[0][3];}
inline Complex LorentzRSSpinorBar::ys1() const {return _spin[1][0];}
inline Complex LorentzRSSpinorBar::ys2() const {return _spin[1][1];}
inline Complex LorentzRSSpinorBar::ys3() const {return _spin[1][2];}
inline Complex LorentzRSSpinorBar::ys4() const {return _spin[1][3];}
inline Complex LorentzRSSpinorBar::zs1() const {return _spin[2][0];}
inline Complex LorentzRSSpinorBar::zs2() const {return _spin[2][1];}
inline Complex LorentzRSSpinorBar::zs3() const {return _spin[2][2];}
inline Complex LorentzRSSpinorBar::zs4() const {return _spin[2][3];}
inline Complex LorentzRSSpinorBar::ts1() const {return _spin[3][0];}
inline Complex LorentzRSSpinorBar::ts2() const {return _spin[3][1];}
inline Complex LorentzRSSpinorBar::ts3() const {return _spin[3][2];}
inline Complex LorentzRSSpinorBar::ts4() const {return _spin[3][3];}

// Set components
inline void LorentzRSSpinorBar::setXS1(Complex in){_spin[0][0]=in;}
inline void LorentzRSSpinorBar::setXS2(Complex in){_spin[0][1]=in;}
inline void LorentzRSSpinorBar::setXS3(Complex in){_spin[0][2]=in;}
inline void LorentzRSSpinorBar::setXS4(Complex in){_spin[0][3]=in;}
inline void LorentzRSSpinorBar::setYS1(Complex in){_spin[1][0]=in;}
inline void LorentzRSSpinorBar::setYS2(Complex in){_spin[1][1]=in;}
inline void LorentzRSSpinorBar::setYS3(Complex in){_spin[1][2]=in;}
inline void LorentzRSSpinorBar::setYS4(Complex in){_spin[1][3]=in;}
inline void LorentzRSSpinorBar::setZS1(Complex in){_spin[2][0]=in;}
inline void LorentzRSSpinorBar::setZS2(Complex in){_spin[2][1]=in;}
inline void LorentzRSSpinorBar::setZS3(Complex in){_spin[2][2]=in;}
inline void LorentzRSSpinorBar::setZS4(Complex in){_spin[2][3]=in;}
inline void LorentzRSSpinorBar::setTS1(Complex in){_spin[3][0]=in;}
inline void LorentzRSSpinorBar::setTS2(Complex in){_spin[3][1]=in;}
inline void LorentzRSSpinorBar::setTS3(Complex in){_spin[3][2]=in;}
inline void LorentzRSSpinorBar::setTS4(Complex in){_spin[3][3]=in;}

// the assignment operator
inline LorentzRSSpinorBar & LorentzRSSpinorBar::
operator = (const LorentzRSSpinorBar & in) {
  _dirac=in._dirac;
  _type=in._type;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix){for(iy=0;iy<4;++iy){_spin[ix][iy]=in._spin[ix][iy];}}
  return *this;
}

// return the representation of the spinor
inline DiracRep LorentzRSSpinorBar::Rep(){return _dirac;}

// return thetype of the spinor
inline SpinorType LorentzRSSpinorBar::Type(){return _type;}

// change the dirac matrix representation
inline void LorentzRSSpinorBar::changeRep(DiracRep newdirac)
{if(newdirac!=_dirac) *this = transformRep(newdirac);}


// return the spinor in a different representation
inline LorentzRSSpinorBar LorentzRSSpinorBar::transformRep(DiracRep newdirac)
{
  // do nothing if all ready in the correct representation
  if(newdirac==_dirac){return *this;}
  double fact=1./sqrt(2.);
  // transform from HELAS representation to Haber one
  Complex out[4][4];
  unsigned int ix;
  if(newdirac==HELASDRep && _dirac==HaberDRep)
    {
      for(ix=0;ix<4;++ix)
	{
	  out[ix][0] = fact*( _spin[ix][0]-_spin[ix][2]);
	  out[ix][1] = fact*( _spin[ix][1]-_spin[ix][3]);
	  out[ix][2] = fact*( _spin[ix][0]+_spin[ix][2]);
	  out[ix][3] = fact*( _spin[ix][1]+_spin[ix][3]);
	}
    }
  // transform from Haber representation to HELAS one
  else if(newdirac==HaberDRep && _dirac==HELASDRep)
    {
      for(ix=0;ix<4;++ix)
	{
	  out[ix][0] = fact*( _spin[ix][0]+_spin[ix][2]);
	  out[ix][1] = fact*( _spin[ix][1]+_spin[ix][3]);
	  out[ix][2] = fact*(-_spin[ix][0]+_spin[ix][2]);
	  out[ix][3] = fact*(-_spin[ix][1]+_spin[ix][3]);
	}
    }
  return LorentzRSSpinorBar(out[0][0],out[0][1],out[0][2],out[0][3],
			    out[1][0],out[1][1],out[1][2],out[1][3],
			    out[2][0],out[2][1],out[2][2],out[2][3],
			    out[3][0],out[3][1],out[3][2],out[3][3],_type,_dirac);
}

// dot product with a 4-vector or polarization vector
inline LorentzSpinorBar LorentzRSSpinorBar::dot(const LorentzPolarizationVector & vec) const
{
  LorentzSpinorBar output(_type,_dirac);
  Complex temp;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix)
    {
      temp=_spin[3][ix]*vec[3];
      for(iy=0;iy<3;++iy){temp-=_spin[iy][ix]*vec[iy];}
      output[ix]=temp;
    }
  return output;
}
  
inline LorentzSpinorBar LorentzRSSpinorBar::dot(const LorentzVector & vec) const
{
  LorentzSpinorBar output(_type,_dirac);
  Complex temp;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix)
    {
      temp=_spin[3][ix]*vec[3];
      for(iy=0;iy<3;++iy){temp-=_spin[iy][ix]*vec[iy];}
      output[ix]=temp;
    }
  return output;
}

inline LorentzPolarizationVector  LorentzRSSpinorBar::generalCurrent(LorentzSpinor& f,
								     Complex left,
								     Complex right)
{
  LorentzPolarizationVector output;
  // ensure both spinors are in the same representation, otherwise change to default
  if(Rep()!=f.Rep())
    {
      f.changeRep(defaultDRep);
      changeRep(defaultDRep);
    }
  unsigned int iz;
  // low energy
  if(Rep()==HaberDRep)
    {
      for(iz=0;iz<4;++iz)
	{output[iz] = 
	    0.5*left*( (_spin[iz][0]-_spin[iz][2])*(f.s1()-f.s3())
		      +(_spin[iz][1]-_spin[iz][3])*(f.s2()-f.s4()))
	  +0.5*right*( (_spin[iz][0]+_spin[iz][2])*(f.s1()+f.s3())
		      +(_spin[iz][1]+_spin[iz][3])*(f.s2()+f.s4()));}
    }
  else
    {
      for(iz=0;iz<4;++iz)
	{output[iz]=  left*(_spin[iz][0]*f.s1()+_spin[iz][1]*f.s2())
	            +right*(_spin[iz][2]*f.s3()+_spin[iz][3]*f.s4());}
    }
  return output;
}
}
}

