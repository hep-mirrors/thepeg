
// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzRSSpinorBar class.
//
// Author: Peter Richardson
//

namespace ThePEG {
namespace Helicity {

// inlined function of the LorentzRSSpinorBar class
// default zero constructor
template <typename Value> inline LorentzRSSpinorBar<Value>::LorentzRSSpinorBar(DiracRep dirac) {
  _dirac=dirac;
  _type=unknown_spinortype;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix) {
    for(iy=0;iy<4;++iy){
      _spin[ix][iy]=complex<Value>();
    }
  }
}

template <typename Value> inline LorentzRSSpinorBar<Value>::LorentzRSSpinorBar(SpinorType type, DiracRep dirac) {
  _dirac=dirac;
  _type=type;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix) {
    for(iy=0;iy<4;++iy) {
      _spin[ix][iy]=complex<Value>();
    }
  }
}

// constructor with complex numbers
template <typename Value> inline LorentzRSSpinorBar<Value>::
LorentzRSSpinorBar(complex<Value> a1,complex<Value> b1, complex<Value> c1,complex<Value> d1,
		   complex<Value> a2,complex<Value> b2, complex<Value> c2,complex<Value> d2,
		   complex<Value> a3,complex<Value> b3, complex<Value> c3,complex<Value> d3,
		   complex<Value> a4,complex<Value> b4, complex<Value> c4,complex<Value> d4,DiracRep dirac) {
  _dirac=dirac;
  _type=unknown_spinortype;
  _spin[0][0]=a1;_spin[1][0]=a2;_spin[2][0]=a3;_spin[3][0]=a4;
  _spin[0][1]=b1;_spin[1][1]=b2;_spin[2][1]=b3;_spin[3][1]=b4;
  _spin[0][2]=c1;_spin[1][2]=c2;_spin[2][2]=c3;_spin[3][2]=c4;
  _spin[0][3]=d1;_spin[1][3]=d2;_spin[2][3]=d3;_spin[3][3]=d4;
}

template <typename Value> inline LorentzRSSpinorBar<Value>::
LorentzRSSpinorBar(complex<Value> a1,complex<Value> b1, complex<Value> c1,complex<Value> d1,
		   complex<Value> a2,complex<Value> b2, complex<Value> c2,complex<Value> d2,
		   complex<Value> a3,complex<Value> b3, complex<Value> c3,complex<Value> d3,
		   complex<Value> a4,complex<Value> b4, complex<Value> c4,complex<Value> d4,SpinorType type,
		   DiracRep dirac) {
  _dirac=dirac;
  _type=type;
  _spin[0][0]=a1;_spin[1][0]=a2;_spin[2][0]=a3;_spin[3][0]=a4;
  _spin[0][1]=b1;_spin[1][1]=b2;_spin[2][1]=b3;_spin[3][1]=b4;
  _spin[0][2]=c1;_spin[1][2]=c2;_spin[2][2]=c3;_spin[3][2]=c4;
  _spin[0][3]=d1;_spin[1][3]=d2;_spin[2][3]=d3;_spin[3][3]=d4;
}

  template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::operator()(int i,int j) const
{
  if ( i >= 0 && i <= 3 && j>=0 && j<=3) return _spin[i][j];
  else throw HelicityLogicalError()
    << "Invalid component of LorentzRSSpinorBar Requested. Component:" << i << " " << j
    << Exception::abortnow;
}

// set components by index
  template <typename Value> inline complex<Value> & LorentzRSSpinorBar<Value>::operator () (int i,int j){
  if ( i>= 0 && i <= 3 && j>=0 && j<=3) return _spin[i][j];
  throw HelicityLogicalError()
    << "Invalid index " << i << " " << j << " called for LorentzRSSpinorBar."
    << Exception::abortnow;
}

// Get components
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::xs1() const {return _spin[0][0];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::xs2() const {return _spin[0][1];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::xs3() const {return _spin[0][2];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::xs4() const {return _spin[0][3];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::ys1() const {return _spin[1][0];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::ys2() const {return _spin[1][1];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::ys3() const {return _spin[1][2];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::ys4() const {return _spin[1][3];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::zs1() const {return _spin[2][0];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::zs2() const {return _spin[2][1];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::zs3() const {return _spin[2][2];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::zs4() const {return _spin[2][3];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::ts1() const {return _spin[3][0];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::ts2() const {return _spin[3][1];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::ts3() const {return _spin[3][2];}
template <typename Value> inline complex<Value> LorentzRSSpinorBar<Value>::ts4() const {return _spin[3][3];}

// Set components
template <typename Value> inline void LorentzRSSpinorBar<Value>::setXS1(complex<Value> in){_spin[0][0]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setXS2(complex<Value> in){_spin[0][1]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setXS3(complex<Value> in){_spin[0][2]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setXS4(complex<Value> in){_spin[0][3]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setYS1(complex<Value> in){_spin[1][0]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setYS2(complex<Value> in){_spin[1][1]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setYS3(complex<Value> in){_spin[1][2]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setYS4(complex<Value> in){_spin[1][3]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setZS1(complex<Value> in){_spin[2][0]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setZS2(complex<Value> in){_spin[2][1]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setZS3(complex<Value> in){_spin[2][2]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setZS4(complex<Value> in){_spin[2][3]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setTS1(complex<Value> in){_spin[3][0]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setTS2(complex<Value> in){_spin[3][1]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setTS3(complex<Value> in){_spin[3][2]=in;}
template <typename Value> inline void LorentzRSSpinorBar<Value>::setTS4(complex<Value> in){_spin[3][3]=in;}

// the assignment operator
template <typename Value> inline LorentzRSSpinorBar<Value> & LorentzRSSpinorBar<Value>::
operator = (const LorentzRSSpinorBar & in) {
  _dirac=in._dirac;
  _type=in._type;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix){for(iy=0;iy<4;++iy){_spin[ix][iy]=in._spin[ix][iy];}}
  return *this;
}

// return the representation of the spinor
template <typename Value> inline DiracRep LorentzRSSpinorBar<Value>::Rep(){return _dirac;}

// return thetype of the spinor
template <typename Value> inline SpinorType LorentzRSSpinorBar<Value>::Type(){return _type;}

// change the dirac matrix representation
template <typename Value> inline void LorentzRSSpinorBar<Value>::changeRep(DiracRep newdirac)
{if(newdirac!=_dirac) *this = transformRep(newdirac);}


// return the spinor in a different representation
template <typename Value> inline LorentzRSSpinorBar<Value> LorentzRSSpinorBar<Value>::transformRep(DiracRep newdirac)
{
  // do nothing if all ready in the correct representation
  if(newdirac==_dirac){return *this;}
  double fact=1./sqrt(2.);
  // transform from HELAS representation to Haber one
  complex<Value> out[4][4];
  unsigned int ix;
  if(newdirac==HELASDRep && _dirac==HaberDRep)
    {
      for(ix=0;ix<4;++ix)
	{
	  out[ix][0] = fact*( _spin[ix][0]-_spin[ix][2]);
	  out[ix][1] = fact*( _spin[ix][1]-_spin[ix][3]);
	  out[ix][2] = fact*( _spin[ix][0]+_spin[ix][2]);
	  out[ix][3] = fact*( _spin[ix][1]+_spin[ix][3]);
	}
    }
  // transform from Haber representation to HELAS one
  else if(newdirac==HaberDRep && _dirac==HELASDRep)
    {
      for(ix=0;ix<4;++ix)
	{
	  out[ix][0] = fact*( _spin[ix][0]+_spin[ix][2]);
	  out[ix][1] = fact*( _spin[ix][1]+_spin[ix][3]);
	  out[ix][2] = fact*(-_spin[ix][0]+_spin[ix][2]);
	  out[ix][3] = fact*(-_spin[ix][1]+_spin[ix][3]);
	}
    }
  return LorentzRSSpinorBar(out[0][0],out[0][1],out[0][2],out[0][3],
			    out[1][0],out[1][1],out[1][2],out[1][3],
			    out[2][0],out[2][1],out[2][2],out[2][3],
			    out[3][0],out[3][1],out[3][2],out[3][3],_type,_dirac);
}

// dot product with a 4-vector or polarization vector
template <typename Value> 
inline LorentzSpinorBar<Value> 
LorentzRSSpinorBar<Value>::dot(const LorentzPolarizationVector & vec) const
{
  LorentzSpinorBar<Value> output(_type,_dirac);
  complex<Value> temp;
  unsigned int ix;
  for(ix=0;ix<4;++ix)
    {
      temp=_spin[3][ix]*vec.t();
      temp-=_spin[0][ix]*vec.x();
      temp-=_spin[1][ix]*vec.y();
      temp-=_spin[2][ix]*vec.z();
      output[ix]=temp;
    }
  return output;
}
  
template <typename Value> 
inline LorentzSpinorBar<Value> 
LorentzRSSpinorBar<Value>::dot(const LorentzMomentum & invec) const
{
  LorentzSpinorBar<Value> output(_type,_dirac);
  complex<Value> temp;
  LorentzVector<double> vec = UnitRemoval::InvE * invec;
  unsigned int ix;
  for(ix=0;ix<4;++ix)
    {
      temp= -(_spin[0][ix]*vec.x() + _spin[1][ix]*vec.y()
	      + _spin[2][ix]*vec.z() ) + _spin[3][ix]*vec.t();
      output[ix]=temp;
    }
  return output;
}

template <typename Value> 
template <typename ValueB>
inline LorentzVector<complex<
  typename BinaryOpTraits<Value,ValueB>::MulT> >
LorentzRSSpinorBar<Value>::generalCurrent(LorentzSpinor<ValueB>& f,
					  Complex left,
					  Complex right)
{
  typedef complex<typename BinaryOpTraits<Value,ValueB>::MulT> ResultT;
  ResultT output[4];
  // ensure both spinors are in the same representation, otherwise change to default
  if(Rep()!=f.Rep())
    {
      f.changeRep(defaultDRep);
      changeRep(defaultDRep);
    }
  unsigned int iz;
  // low energy
  if(Rep()==HaberDRep)
    {
      for(iz=0;iz<4;++iz)
	{output[iz] = 
	    0.5*left*( (_spin[iz][0]-_spin[iz][2])*(f.s1()-f.s3())
		      +(_spin[iz][1]-_spin[iz][3])*(f.s2()-f.s4()))
	  +0.5*right*( (_spin[iz][0]+_spin[iz][2])*(f.s1()+f.s3())
		      +(_spin[iz][1]+_spin[iz][3])*(f.s2()+f.s4()));}
    }
  else
    {
      for(iz=0;iz<4;++iz)
	{output[iz]=  left*(_spin[iz][0]*f.s1()+_spin[iz][1]*f.s2())
	            +right*(_spin[iz][2]*f.s3()+_spin[iz][3]*f.s4());}
    }
  return LorentzVector<ResultT>(output[0],output[1],output[2],output[3]);
}
}
}

