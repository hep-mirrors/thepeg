// -*- C++ -*-
//
// VertexBase.icc is a part of ThePEG - Toolkit for HEP Event Generation
// Copyright (C) 2003-2007 Peter Richardson, Leif Lonnblad
//
// ThePEG is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the VertexBase class.
//

namespace ThePEG {
namespace Helicity{

// constructors for three point vertices
inline VertexBase::VertexBase(int isa, int isb, int isc,vector<int> ida,
			      vector<int> idb,vector<int> idc,bool kine) 
  : _coupopt(0), _gs(sqrt(4.*Constants::pi*0.3)), _ee(sqrt(4.*Constants::pi/137.04)),
    _sw(sqrt(0.232)) {
  // number of external particles
  _npoint = 3;
  // initialise the spins
  setSpin(isa,isb,isc);
  // and the particles;
  setList(ida,idb,idc);
  _calckinematics=kine;
}

// constructors for four  point vertices
inline VertexBase::VertexBase(int isa,int isb, int isc, int isd,
			      vector<int> ida, vector<int> idb,
			      vector<int> idc, vector<int> idd, bool kine) 
  : _coupopt(0), _gs(sqrt(4.*Constants::pi*0.3)), _ee(sqrt(4.*Constants::pi/137.04)),
    _sw(sqrt(0.232)) {
  // number of external particles
  _npoint = 4;
  // initialise the spins
  setSpin(isa,isb,isc,isd);
  // and the particles
  setList(ida,idb,idc,idd);
  _calckinematics=kine;
}

// constructors for five point vertices
inline VertexBase::VertexBase(int ia, int ib, int ic, int id , int ie,
			      vector<int> ida,vector<int> idb,
			      vector<int> idc,vector<int> idd,
			      vector<int> ide,bool kine) 
  : _coupopt(0), _gs(sqrt(4.*Constants::pi*0.3)), _ee(sqrt(4.*Constants::pi/137.04)),
    _sw(sqrt(0.232)) {
  // number of external particles
  _npoint = 5;
  // initialise the spins
  setSpin(ia,ib,ic,id,ie);
  // and the particles
  setList(ida,idb,idc,idd,ide);
  _calckinematics=kine;
}

// default constructor
inline VertexBase::VertexBase(unsigned int nin, bool kine) 
  : _npoint(nin), _calckinematics(kine),
    _coupopt(0), _gs(sqrt(4.*Constants::pi*0.3)), _ee(sqrt(4.*Constants::pi/137.04)),
    _sw(sqrt(0.232)) 
{}

// setup the spins

// three point vertex
inline void VertexBase::setSpin(int ia,int ib,int ic){
  if(_ispin.size()!=0)
    throw HelicityConsistencyError() << "VertexBase::setSpin the spins have already "
				     << "been set" << Exception::warning;
  else if(_npoint!=3)
    throw HelicityConsistencyError() << "VertexBase::setSpin not a three point vertex" 
				      << Exception::abortnow;
  else {
    _ispin.push_back(ia);
    _ispin.push_back(ib);
    _ispin.push_back(ic);
  }
}

// four point vertex
inline void VertexBase::setSpin(int ia,int ib,int ic, int id){
  if(_ispin.size()!=0)
    {throw HelicityConsistencyError() << "VertexBase::setSpin the spins have already "
				      << "been set" << Exception::warning;}
  else if(_npoint!=4)
    {throw HelicityConsistencyError() << "VertexBase::setSpin not a four point vertex" 
				      << Exception::abortnow;}
  else
    {_ispin.push_back(ia);_ispin.push_back(ib);_ispin.push_back(ic);
    _ispin.push_back(id);}
}

// five point vertex
inline void VertexBase::setSpin(int ia,int ib,int ic, int id, int ie){
  if(_ispin.size()!=0)
    {throw HelicityConsistencyError() << "VertexBase::setSpin the spins have already "
				      << "been set" << Exception::warning;}
  else if(_npoint!=5)
    {throw HelicityConsistencyError() << "VertexBase::setSpin not a five point vertex" 
				      << Exception::abortnow;}
    else
      {_ispin.push_back(ia);_ispin.push_back(ib);_ispin.push_back(ic);
      _ispin.push_back(id);_ispin.push_back(ie);}
}

// number of different particle combinations allowed
inline unsigned int VertexBase::size() {
  return _nsize;
}

// set and get functions for the number of external particles
inline unsigned int VertexBase::getNpoint() {
  return _npoint;
}

inline void VertexBase::setNpoint(unsigned int in) {
  _npoint=in;
}

// is a particle allowed as an incoming particle
inline bool VertexBase::incoming(int id) {
  if(_iinpart.size()==0) return false; 
  for(unsigned int ix=0;ix<_iinpart.size();++ix) {
    if(_iinpart[ix]==id) return true;
  }
  return false;
}

// is a particle allowed as an outgoing particle
inline bool VertexBase::outgoing(int id) {
  if(_outpart.size()==0) return false; 
  for(unsigned int ix=0;ix<_ioutpart.size();++ix) {
    if(_ioutpart[ix]==id) return true;
  }
  return false;
}

// get the list of incoming particles
inline vector<PDPtr> VertexBase::getIncoming() {
  return _inpart;
}

// get the list of outgoing particles
inline vector<PDPtr> VertexBase::getOutgoing() {
  return _outpart;
}

// set the coupling
inline void VertexBase::setNorm(const Complex & in) {
  _norm = in;
}

// get the coupling
inline const Complex & VertexBase::getNorm() {
  return _norm;
}

// calculate the propagator for a diagram
inline Complex VertexBase::propagator(int iopt, Energy2 p2,tcPDPtr part) {
  const Energy mass = part->mass();
  const Energy2 mass2 = sqr(mass);
  const Energy p = sqrt(p2);

  const tcWidthGeneratorPtr widthgen = part->widthGenerator();
  const Energy width = widthgen ? widthgen->width(*part,p) : part->width();
  const Complex ii(0.,1.);

  complex<Energy2> masswidth;
  if(iopt==5) {
    return Complex(UnitRemoval::E2/p2);
  }
  else if(p2 < 0.*MeV2) {
    masswidth = 0.*MeV2;
  }
  else {
    switch (iopt) {
    case 1: 
      masswidth = ii * mass * part->width(); 
      break;
    case 2: 
      masswidth = ii * mass * width;         
      break;
    case 3: 
      masswidth = 0.*MeV2;                    
      break;
    case 4: 
      return 1.0;
    case 6: 
      masswidth = ii * mass2 * width / p;
      return Complex(UnitRemoval::E2 * (mass2/p2) / (p2-mass2+masswidth));
    default:
      throw HelicityConsistencyError() << "Unknown option in VertexBase::Propagator" 
				       << Exception::abortnow;
    }
  }
  return Complex(UnitRemoval::E2/(p2-mass2+masswidth));
}
  
// propagator times coupling for a diagram
inline Complex VertexBase::normPropagator(int iopt, Energy2 p2,tcPDPtr part) {
  return _norm*propagator(iopt,p2,part);
}

inline bool VertexBase::kinematics() {
  return _calckinematics;
}

inline void VertexBase::kinematics(bool kine) {
  _calckinematics=kine;
}

inline void VertexBase::calculateKinematics(const Lorentz5Momentum & p0,
					    const Lorentz5Momentum & p2,
					    const Lorentz5Momentum & p1) {
  _kine[0][0]=p0*p0;
  _kine[1][1]=p1*p1;
  _kine[2][2]=p2*p2;
  _kine[0][1]=p0*p1;_kine[1][0]=_kine[0][1];
  _kine[0][2]=p0*p2;_kine[2][0]=_kine[0][2];
  _kine[1][2]=p1*p2;_kine[2][1]=_kine[1][2];
}
 
inline void VertexBase::calculateKinematics(const Lorentz5Momentum & p0,
					    const Lorentz5Momentum & p1,
					    const Lorentz5Momentum & p2,
					    const Lorentz5Momentum & p3) {
  _kine[0][0]=p0*p0;
  _kine[1][1]=p1*p1;
  _kine[2][2]=p2*p2;
  _kine[3][3]=p3*p3;
  _kine[0][1]=p0*p1;_kine[1][0]=_kine[0][1];
  _kine[0][2]=p0*p2;_kine[2][0]=_kine[0][2];
  _kine[0][3]=p0*p3;_kine[3][0]=_kine[0][3];
  _kine[1][2]=p1*p2;_kine[2][1]=_kine[1][2];
  _kine[1][3]=p1*p3;_kine[3][1]=_kine[1][3];
  _kine[2][3]=p2*p3;_kine[3][2]=_kine[2][3];
}

inline void VertexBase::calculateKinematics(const Lorentz5Momentum & p0,
					    const Lorentz5Momentum & p1,
					    const Lorentz5Momentum & p2,
					    const Lorentz5Momentum & p3,
					    const Lorentz5Momentum & p4) {
  _kine[0][0]=p0*p0;
  _kine[1][1]=p1*p1;
  _kine[2][2]=p2*p2;
  _kine[3][3]=p3*p3;
  _kine[4][4]=p4*p4;
  _kine[0][1]=p0*p1;_kine[1][0]=_kine[0][1];
  _kine[0][2]=p0*p2;_kine[2][0]=_kine[0][2];
  _kine[0][3]=p0*p3;_kine[3][0]=_kine[0][3];
  _kine[0][4]=p0*p4;_kine[4][0]=_kine[0][4];
  _kine[1][2]=p1*p2;_kine[2][1]=_kine[1][2];
  _kine[1][3]=p1*p3;_kine[3][1]=_kine[1][3];
  _kine[1][4]=p1*p4;_kine[4][1]=_kine[1][4];
  _kine[2][3]=p2*p3;_kine[3][2]=_kine[2][3];
  _kine[2][4]=p2*p4;_kine[4][2]=_kine[2][4];
  _kine[3][4]=p3*p4;_kine[4][3]=_kine[3][4];
}
  
inline void VertexBase::calculateKinematics(const vector<Lorentz5Momentum> & p) {
  unsigned int ix,iy;
  for(ix=0;ix<p.size();++ix) {
    for(iy=0;iy<=ix;++ix) {
      _kine[ix][iy]=p[ix]*p[iy];
      _kine[iy][ix]=_kine[ix][iy];
    }
  }
}

inline Energy2 VertexBase::invariant(unsigned int ix,unsigned int iy) {
  if(ix>_npoint||iy>_npoint)
    throw Exception() << "Invalid invariant requested in VertexBase::invariant() " 
		      << ix << " " << iy << Exception::abortnow;
  return _kine[ix][iy];
}
 

inline void VertexBase::setName(const VertexType & name){
  _theName = name;
}

inline VertexType VertexBase::getName() const {
  return _theName;
}

inline void VertexBase::orderInGem(unsigned int order) {
  _ordergEM = order;
}

inline void VertexBase::orderInGs(unsigned int order){
  _ordergS = order;
}

inline unsigned int VertexBase::orderInGem() const {
  return _ordergEM;
}

inline unsigned int VertexBase::orderInGs() const {
  return _ordergS;
}

inline double VertexBase::strongCoupling(Energy2 q2) {
  if(_coupopt==0) {
    return sqrt(4.0*Constants::pi*generator()->standardModel()->alphaS(q2));
  }
  else if(_coupopt==1) {
    return sqrt(4.0*Constants::pi*generator()->standardModel()->alphaS());
  }
  else {
    return _gs;
  }
}

inline double VertexBase::electroMagneticCoupling(Energy2 q2) {
  if(_coupopt==0) {
    return sqrt(4.0*Constants::pi*generator()->standardModel()->alphaEM(q2));
  }
  else if(_coupopt==1) {
    return sqrt(4.0*Constants::pi*generator()->standardModel()->alphaEM());
  }
  else {
    return _ee;
  }
}

inline double VertexBase::weakCoupling(Energy2 q2) {
  if(_coupopt==0) {
    return sqrt(4.0*Constants::pi*generator()->standardModel()->alphaEM(q2)/
		generator()->standardModel()->sin2ThetaW());
  }
  else if(_coupopt==1) {
    return sqrt(4.0*Constants::pi*generator()->standardModel()->alphaEM()/
		generator()->standardModel()->sin2ThetaW());
  }
  else {
    return _ee/_sw;
  }
}

}
}
