// -*- C++ -*-
//
// LorentzSpinor.icc is a part of ThePEG - Toolkit for HEP Event Generation
// Copyright (C) 2003-2007 Peter Richardson, Leif Lonnblad
//
// ThePEG is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the LorentzSpinor class.
//
// Author: Peter Richardson
//

#include "ThePEG/Helicity/HelicityDefinitions.h"

namespace ThePEG {
namespace Helicity {

// default zero constructor
template <typename Value> inline LorentzSpinor<Value>::LorentzSpinor(DiracRep d) 
  : _dirac(d), _type(unknown_spinortype), _spin(4) {}

template <typename Value> inline LorentzSpinor<Value>::LorentzSpinor(SpinorType s,DiracRep d) 
  : _dirac(d), _type(s), _spin(4) {}

// constructor with complex numbers

template <typename Value> inline LorentzSpinor<Value>::
LorentzSpinor(complex<Value> a, complex<Value> b, complex<Value> c, complex<Value> d, DiracRep r) 
  : _dirac(r), _type(unknown_spinortype), _spin(4) {
  _spin[0]=a;
  _spin[1]=b;
  _spin[2]=c;
  _spin[3]=d;
}

template <typename Value> inline LorentzSpinor<Value>::
LorentzSpinor(complex<Value> a, complex<Value> b, complex<Value> c, complex<Value> d, SpinorType s,DiracRep r) 
  : _dirac(r), _type(s), _spin(4) {
  _spin[0]=a;
  _spin[1]=b;
  _spin[2]=c;
  _spin[3]=d;
}

// subscript operator to return spinor components
template <typename Value> inline complex<Value> LorentzSpinor<Value>::operator[](int i) const
{
  if ( i >= 0 && i <= 3 ) return _spin[i];
  throw HelicityLogicalError()
    << "Invalid component of LorentzSpinor requested. Component:" << i
    << Exception::abortnow;
}

template <typename Value> inline complex<Value> LorentzSpinor<Value>::operator()(int i) const
{
  if ( i >= 0 && i <= 3 ) return _spin[i];
  throw HelicityLogicalError()
    << "Invalid component of LorentzSpinor Requested. Component:" << i
    << Exception::abortnow;
}

// set components by index
template <typename Value> inline complex<Value> & LorentzSpinor<Value>::operator () (int i){
  if ( i >= 0 && i <= 3 ) return _spin[i];
  throw HelicityLogicalError()
    << "Invalid index " << i << " called for LorentzSpinor."
    << Exception::abortnow;
}

template <typename Value> inline complex<Value> & LorentzSpinor<Value>::operator [] (int i){
  if ( i >= 0 && i <=3 ) return _spin[i];
  throw HelicityLogicalError()
    << "Invalid index " << i << " called for LorentzSpinor."
    << Exception::abortnow;
}

// Get components
template <typename Value> inline complex<Value> LorentzSpinor<Value>::s1() const {return _spin[0];}

template <typename Value> inline complex<Value> LorentzSpinor<Value>::s2() const {return _spin[1];}

template <typename Value> inline complex<Value> LorentzSpinor<Value>::s3() const {return _spin[2];}

template <typename Value> inline complex<Value> LorentzSpinor<Value>::s4() const {return _spin[3];}

// Set components
template <typename Value> inline void LorentzSpinor<Value>::setS1(complex<Value> in){_spin[0]=in;}

template <typename Value> inline void LorentzSpinor<Value>::setS2(complex<Value> in){_spin[1]=in;}

template <typename Value> inline void LorentzSpinor<Value>::setS3(complex<Value> in){_spin[2]=in;}

template <typename Value> inline void LorentzSpinor<Value>::setS4(complex<Value> in){_spin[3]=in;}

// change the dirac matrix representation
template <typename Value> inline void LorentzSpinor<Value>::changeRep(DiracRep newdirac)
{
  if(newdirac!=_dirac) *this = transformRep(newdirac);
}

// return the spinor in a different representation
template <typename Value> 
inline LorentzSpinor<Value> 
LorentzSpinor<Value>::transformRep(DiracRep newdirac) const
{
  // do nothing if all ready in the correct representation
  if(newdirac==_dirac) return LorentzSpinor(*this);
  double fact=1./sqrt(2.);
  // transform from HELAS representation to Haber one
  complex<Value> output[4];
  if(newdirac==HELASDRep && _dirac==HaberDRep) {
    output[0] =-fact*( _spin[0]-_spin[2]);
    output[1] =-fact*( _spin[1]-_spin[3]);
    output[2] =-fact*( _spin[0]+_spin[2]);
    output[3] =-fact*( _spin[1]+_spin[3]);
  }
  // transform from Haber representation to HELAS one
  else if(newdirac==HaberDRep && _dirac==HELASDRep) {
    output[0] =-fact*( _spin[0]+_spin[2]);
    output[1] =-fact*( _spin[1]+_spin[3]);
    output[2] =-fact*(-_spin[0]+_spin[2]);
    output[3] =-fact*(-_spin[1]+_spin[3]);
  }
  // return the answer
  return LorentzSpinor(output[0],output[1],output[2],output[3],_type,newdirac);
}

// return the representation of the spinor
template <typename Value> 
inline const DiracRep LorentzSpinor<Value>::Rep() const {
  return _dirac;
}

// return the type of the spinor
template <typename Value> 
inline const SpinorType LorentzSpinor<Value>::Type() const {
  return _type;
}

// calculate the left-handed current
template <typename Value> 
template <typename ValueB>
inline LorentzVector<complex<
  typename BinaryOpTraits<Value,ValueB>::MulT> >
LorentzSpinor<Value>::leftCurrent(const LorentzSpinorBar<ValueB>& fb) const
{
  typedef complex<typename BinaryOpTraits<Value,ValueB>::MulT> ResultT;
  // ensure both spinors are in the same representation, otherwise change to default
  LorentzSpinorBar<ValueB> fbar(fb);
  if(Rep()!=fb.Rep()) fbar.changeRep(Rep());
  LorentzVector<ResultT> vec;
  Complex ii(0.,1.);
  // Haber representation
  if(Rep()==HaberDRep)
    {
      complex<Value> s2m4(s2()-s4()), s1m3(s1()-s3());
      complex<ValueB> sb1p3(fbar.s1()+fbar.s3()), sb2p4(fbar.s2()+fbar.s4());
      ResultT p1(sb1p3*s2m4),p2(sb2p4*s1m3);
      vec.setX( -0.5*(p1+p2) );
      vec.setY( ii*0.5*(p1-p2) );
      p1 = sb1p3*s1m3; p2=sb2p4*s2m4;
      vec.setZ( -0.5*(p1-p2) );
      vec.setT( 0.5*(p1+p2) );
    }
  // HELAS representation
  else
    {
      ResultT p1(fbar.s3()*s2()),p2(fbar.s4()*s1());
      vec.setX(   -(p1+p2) );
      vec.setY( ii*(p1-p2) );
      p1 = fbar.s3()*s1();p2 = fbar.s4()*s2();
      vec.setZ(   -(p1-p2) );
      vec.setT(    (p1+p2) );
    }
  return vec;
}

// calculate the right-handed current
template <typename Value>   
template <typename ValueB>
inline LorentzVector<complex< typename BinaryOpTraits<Value,ValueB>::MulT> >
LorentzSpinor<Value>::rightCurrent(const LorentzSpinorBar<ValueB>& fb) const
{
  typedef complex<typename BinaryOpTraits<Value,ValueB>::MulT> ResultT;
  // ensure both spinors are in the same representation, otherwise change to default
  LorentzSpinorBar<ValueB> fbar(fb);
  if(Rep()!=fbar.Rep()) fbar.changeRep(Rep());
  LorentzVector<ResultT> vec;
  Complex ii(0.,1.);
  // Haber representation
  if(Rep()==HaberDRep)
    {
      complex<Value> s2p4(s2()+s4()),s1p3(s1()+s3());
      complex<ValueB> sb1m3(fbar.s1()-fbar.s3()),sb2m4(fbar.s2()-fbar.s4());
      ResultT p1(sb1m3*s2p4),p2(sb2m4*s1p3);
      vec.setX(    +0.5*( p1+p2));
      vec.setY( +ii*0.5*(-p1+p2));
      p1 = sb1m3*s1p3; p2=sb2m4*s2p4;
      vec.setZ(    +0.5*(+p1-p2));
      vec.setT(    +0.5*(+p1+p2));
    }
  // HELAS representation
  else
    {
      ResultT p1(fbar.s1()*s4()),p2(fbar.s2()*s3());
      vec.setX(     (p1+p2));
      vec.setY( -ii*(p1-p2));
      p1 = fbar.s1()*s3();p2 = fbar.s2()*s4();
      vec.setZ(     (p1-p2));
      vec.setT(     (p1+p2));
    }
  return vec;
}

// calculate the vector-handed current
template <typename Value> 
template <typename ValueB>
inline LorentzVector<complex< typename BinaryOpTraits<Value,ValueB>::MulT> >
LorentzSpinor<Value>::vectorCurrent(const LorentzSpinorBar<ValueB>& fb) const
{
  typedef complex<typename BinaryOpTraits<Value,ValueB>::MulT> ResultT;
  // ensure both spinors are in the same representation, otherwise change to default
  LorentzSpinorBar<ValueB> fbar(fb);
  if(Rep()!=fbar.Rep()) fbar.changeRep(Rep());
  LorentzVector<ResultT> vec;
  // calculate the current
  Complex ii(0.,1.);
  ResultT s1s4(fbar.s1()*s4()),s2s3(fbar.s2()*s3()),
    s3s2(fbar.s3()*s2()),s4s1(fbar.s4()*s1()),
    s1s3(fbar.s1()*s3()),s2s4(fbar.s2()*s4()),
    s3s1(fbar.s3()*s1()),s4s2(fbar.s4()*s2());
  if(Rep()==HaberDRep)
    {
      vec.setX(       s1s4+s2s3-s3s2-s4s1);
      vec.setY(  -ii*(s1s4-s2s3-s3s2+s4s1));
      vec.setZ(       s1s3-s2s4-s3s1+s4s2);
      vec.setT( 
	+fbar.s1()*s1()+fbar.s2()*s2()
	-fbar.s3()*s3()-fbar.s4()*s4());
    }
  else
    {
      vec.setX(      s1s4+s2s3-s3s2-s4s1);
      vec.setY( -ii*(s1s4-s2s3-s3s2+s4s1));
      vec.setZ(      s1s3-s2s4-s3s1+s4s2);
      vec.setT(      s1s3+s2s4+s3s1+s4s2);
    }
  return vec;
}

template <typename Value> 
template <typename ValueB>
inline LorentzVector<complex< typename BinaryOpTraits<Value,ValueB>::MulT> >
LorentzSpinor<Value>::generalCurrent(const LorentzSpinorBar<ValueB>& fb,
				     Complex left,
				     Complex right) const
{
  typedef complex<typename BinaryOpTraits<Value,ValueB>::MulT> ResultT;
  // ensure both spinors are in the same representation, otherwise change to default
  LorentzSpinorBar<ValueB> fbar(fb);
  if(Rep()!=fbar.Rep()) fbar.changeRep(Rep());
  LorentzVector<ResultT> vec;
  Complex ii(0.,1.);
  // Haber representation
  if(Rep()==HaberDRep)
    {
      // left handed terms
      complex<Value>  s2m4(s2()-s4()),s1m3(s1()-s3());
      complex<ValueB> sb1p3(fbar.s1()+fbar.s3()), sb2p4(fbar.s2()+fbar.s4());
      ResultT p1(sb1p3*s2m4),p2(sb2p4*s1m3);
      vec.setX(  -0.5*left*(p1+p2));
      vec.setY(ii*0.5*left*(p1-p2));
      p1 = sb1p3*s1m3; p2=sb2p4*s2m4;
      vec.setZ(  -0.5*left*(p1-p2));
      vec.setT(   0.5*left*(p1+p2));
      // right handed terms
      complex<Value> s2p4(s2()+s4()),s1p3(s1()+s3());
      complex<ValueB> sb1m3(fbar.s1()-fbar.s3()), sb2m4(fbar.s2()-fbar.s4());
      p1=sb1m3*s2p4;p2=sb2m4*s1p3;
      vec.setX(vec.x()+0.5*right*( p1+p2));
      vec.setY(vec.y()+ii*0.5*right*(-p1+p2));
      p1 = sb1m3*s1p3; p2=sb2m4*s2p4;
      vec.setZ(vec.z()+0.5*right*(+p1-p2));
      vec.setT(vec.t()+0.5*right*(+p1+p2));
    }
  // HELAS representation
  else
    {
      ResultT p1(fbar.s3()*s2()),p2(fbar.s4()*s1());
      vec.setX(   -left*(p1+p2));
      vec.setY( ii*left*(p1-p2));
      p1 = fbar.s3()*s1();p2 = fbar.s4()*s2();
      vec.setZ(   -left*(p1-p2));
      vec.setT(    left*(p1+p2));
      p1=fbar.s1()*s4();p2=fbar.s2()*s3();
      vec.setX(vec.x()+right*(p1+p2));
      vec.setY(vec.y()-ii*right*(p1-p2));
      p1 = fbar.s1()*s3();p2 = fbar.s2()*s4();
      vec.setZ(vec.z()+right*(p1-p2));
      vec.setT(vec.t()+right*(p1+p2));
    }
  return vec;
}

template <typename Value> 
template <typename ValueB>
inline complex<typename BinaryOpTraits<Value,ValueB>::MulT>
LorentzSpinor<Value>::leftScalar(const LorentzSpinorBar<ValueB>& fb) const
{
  complex<typename BinaryOpTraits<Value,ValueB>::MulT> output;
  // ensure both spinors are in the same representation, otherwise change to default
  LorentzSpinorBar<ValueB> fbar(fb);
  if(Rep()!=fbar.Rep()) fbar.changeRep(Rep());
  // low energy conventions
  if(Rep()==HaberDRep) {
    output = 0.5*( (fbar.s1()-fbar.s3())*(s1()-s3())
		  +(fbar.s2()-fbar.s4())*(s2()-s4()));
  }
  // high energy conventions
  else {
    output=fbar.s1()*s1()+fbar.s2()*s2();
  }
  return output;
}

template <typename Value> 
template <typename ValueB>
inline complex<typename BinaryOpTraits<Value,ValueB>::MulT>
LorentzSpinor<Value>::rightScalar(const LorentzSpinorBar<ValueB>& fb) const
{
  complex<typename BinaryOpTraits<Value,ValueB>::MulT> output;
  // ensure both spinors are in the same representation, otherwise change to default
  LorentzSpinorBar<ValueB> fbar(fb);
  if(Rep()!=fbar.Rep()) fbar.changeRep(Rep());
  // low energy conventions
  if(Rep()==HaberDRep) {
    output = 0.5*( (fbar.s1()+fbar.s3())*(s1()+s3())
		  +(fbar.s2()+fbar.s4())*(s2()+s4()));
  }
  // high energy conventions
  else {
    output=fbar.s3()*s3()+fbar.s4()*s4();
  }
  return output;
}

template <typename Value> 
template <typename ValueB>
inline complex<typename BinaryOpTraits<Value,ValueB>::MulT>
LorentzSpinor<Value>::generalScalar(const LorentzSpinorBar<ValueB>& fb,
				    Complex left,
				    Complex right) const
{
  complex<typename BinaryOpTraits<Value,ValueB>::MulT> output;
  // ensure both spinors are in the same representation, otherwise change to default
  LorentzSpinorBar<ValueB> fbar(fb);
  if(Rep()!=fbar.Rep()) fbar.changeRep(Rep());
  // low energy conventions
  if(Rep()==HaberDRep)
    {
      output = left*( (fbar.s1()-fbar.s3())*(s1()-s3())
		     +(fbar.s2()-fbar.s4())*(s2()-s4()))
	     +right*( (fbar.s1()+fbar.s3())*(s1()+s3())
		     +(fbar.s2()+fbar.s4())*(s2()+s4()));
      output=0.5*output;
    }
  // high energy conventions
  else {
    output=  left*(fbar.s1()*s1()+fbar.s2()*s2())
           +right*(fbar.s3()*s3()+fbar.s4()*s4());
  }
  return output;
}
  
template <typename Value> 
template <typename ValueB>
inline complex<typename BinaryOpTraits<Value,ValueB>::MulT>
LorentzSpinor<Value>::scalar(const LorentzSpinorBar<ValueB>& fb) const
{
  complex<typename BinaryOpTraits<Value,ValueB>::MulT> output;
  // ensure both spinors are in the same representation, otherwise change to default
  LorentzSpinorBar<ValueB> fbar(fb);
  if(Rep()!=fbar.Rep()) fbar.changeRep(Rep());
  // low energy
  if(Rep()==HaberDRep) {
    output=fbar.s1()*s1()+fbar.s2()*s2()+fbar.s3()*s3()+fbar.s4()*s4();
  }
  // high energy
  else {
    output=fbar.s1()*s1()+fbar.s2()*s2()+fbar.s3()*s3()+fbar.s4()*s4();
  }
  return output;
}
  
template <typename Value> 
template <typename ValueB>
inline complex<typename BinaryOpTraits<Value,ValueB>::MulT>
LorentzSpinor<Value>::pseudoScalar(const LorentzSpinorBar<ValueB>& fb) const
{
  complex<typename BinaryOpTraits<Value,ValueB>::MulT> output;
  // ensure both spinors are in the same representation, otherwise change to default
  LorentzSpinorBar<ValueB> fbar(fb);
  if(Rep()!=fbar.Rep()) fbar.changeRep(Rep());
  // low energy
  if(Rep()==HaberDRep) {
    output=fbar.s1()*s3()+fbar.s2()*s4()+fbar.s3()*s1()+fbar.s4()*s2();
  }
  // high energy
  else {
    output=-fbar.s1()*s1()-fbar.s2()*s2()+fbar.s3()*s3()+fbar.s4()*s4();
  }
  return output;
}

template <typename Value> 
inline LorentzSpinor<Value> & 
LorentzSpinor<Value>::transform(const LorentzRotation & r)
{
  SpinHalfLorentzRotation half(r.half());
  transform(half);
  return *this;
}
}
}
