// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzTensor class.
//
// Author: Peter Richardson
//

namespace ThePEG {
namespace Helicity {

// constructors
inline LorentzTensor::LorentzTensor() {
  for(int ix=0;ix<4;++ix) {
    for(int iy=0;iy<4;++iy) {
      _tensor[ix][iy]=0.;
    }
  }
}

// default zero constructor
inline LorentzTensor::
LorentzTensor(LorentzPolarizationVector p, LorentzPolarizationVector q) {
  for(int ix=0;ix<4;++ix) {
    for(int iy=0;iy<4;++iy) {
      _tensor[ix][iy]=p[ix]*q[iy];
    }
  }
}

// constructor in terms of two polarization vectors
// constructor specifying all components
inline LorentzTensor::
LorentzTensor(Complex xx, Complex xy, Complex xz, Complex xt,
	      Complex yx, Complex yy, Complex yz, Complex yt,
	      Complex zx, Complex zy, Complex zz, Complex zt,
	      Complex tx, Complex ty, Complex tz, Complex tt) {
  _tensor[0][0]=xx;_tensor[0][1]=xy;_tensor[0][2]=xz;_tensor[0][3]=xt;
  _tensor[1][0]=yx;_tensor[1][1]=yy;_tensor[1][2]=yz;_tensor[1][3]=yt;
  _tensor[2][0]=zx;_tensor[2][1]=zy;_tensor[2][2]=zz;_tensor[2][3]=zt;
  _tensor[3][0]=tx;_tensor[3][1]=ty;_tensor[3][2]=tz;_tensor[3][3]=tt;
}

inline Complex LorentzTensor::xx() const {return _tensor[0][0];}
inline Complex LorentzTensor::yx() const {return _tensor[1][0];}
inline Complex LorentzTensor::zx() const {return _tensor[2][0];}
inline Complex LorentzTensor::tx() const {return _tensor[3][0];}
inline Complex LorentzTensor::xy() const {return _tensor[0][1];}
inline Complex LorentzTensor::yy() const {return _tensor[1][1];}
inline Complex LorentzTensor::zy() const {return _tensor[2][1];}
inline Complex LorentzTensor::ty() const {return _tensor[3][1];}
inline Complex LorentzTensor::xz() const {return _tensor[0][2];}
inline Complex LorentzTensor::yz() const {return _tensor[1][2];}
inline Complex LorentzTensor::zz() const {return _tensor[2][2];}
inline Complex LorentzTensor::tz() const {return _tensor[3][2];}
inline Complex LorentzTensor::xt() const {return _tensor[0][3];}
inline Complex LorentzTensor::yt() const {return _tensor[1][3];}
inline Complex LorentzTensor::zt() const {return _tensor[2][3];}
inline Complex LorentzTensor::tt() const {return _tensor[3][3];}
// Get position and time.

inline void LorentzTensor::setXX(Complex a) {_tensor[0][0]=a;}
inline void LorentzTensor::setYX(Complex a) {_tensor[1][0]=a;}
inline void LorentzTensor::setZX(Complex a) {_tensor[2][0]=a;}
inline void LorentzTensor::setTX(Complex a) {_tensor[3][0]=a;}
inline void LorentzTensor::setXY(Complex a) {_tensor[0][1]=a;}
inline void LorentzTensor::setYY(Complex a) {_tensor[1][1]=a;}
inline void LorentzTensor::setZY(Complex a) {_tensor[2][1]=a;}
inline void LorentzTensor::setTY(Complex a) {_tensor[3][1]=a;}
inline void LorentzTensor::setXZ(Complex a) {_tensor[0][2]=a;}
inline void LorentzTensor::setYZ(Complex a) {_tensor[1][2]=a;}
inline void LorentzTensor::setZZ(Complex a) {_tensor[2][2]=a;}
inline void LorentzTensor::setTZ(Complex a) {_tensor[3][2]=a;}
inline void LorentzTensor::setXT(Complex a) {_tensor[0][3]=a;}
inline void LorentzTensor::setYT(Complex a) {_tensor[1][3]=a;}
inline void LorentzTensor::setZT(Complex a) {_tensor[2][3]=a;}
inline void LorentzTensor::setTT(Complex a) {_tensor[3][3]=a;}

// Set position and time
inline Complex LorentzTensor::operator () (int i,int j) const
{
  if( i>=0 && i<=3 && j>=0 && j<=3)
    {;}
  else
    {
      std::cerr << "Invalid component of LorentzTensor "
		<< i << " " << j << endl;
      return 0.;
    }
  return _tensor[i][j];
}

// Get components by index.
inline Complex & LorentzTensor::operator () (int i,int j)
{
  static Complex dummy;
  if( i>=0 && i<=3 && j>=0 && j<=3)
    {;}
  else
    {
      std::cerr << "Invalid component of LorentzTensor "
		<< i << " " << j << endl;
      return dummy;
    }
  return _tensor[i][j];
}

// Set components by index.
// Assignment
inline LorentzTensor & LorentzTensor::operator = (const LorentzTensor & q) {
  for(int ix=0;ix<4;++ix) {
    for(int iy=0;iy<4;++iy) _tensor[ix][iy]=q(ix,iy);
  }
  return *this;
}

}
}

