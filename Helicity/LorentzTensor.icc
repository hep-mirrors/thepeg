// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzTensor class.
//
// Author: Peter Richardson
//

#include "ThePEG/Helicity/HelicityDefinitions.h"

namespace ThePEG {
namespace Helicity {

// constructors
// default zero constructor
inline LorentzTensor::LorentzTensor() {
  for(int ix=0;ix<4;++ix) {
    for(int iy=0;iy<4;++iy) {
      _tensor[ix][iy]=0.;
    }
  }
}

// constructor in terms of two polarization vectors
inline LorentzTensor::
LorentzTensor(LorentzPolarizationVector p, LorentzPolarizationVector q) {
  for(int ix=0;ix<4;++ix) {
    for(int iy=0;iy<4;++iy) {
      _tensor[ix][iy]=p[ix]*q[iy];
    }
  }
}

// constructor in terms of two momenta
inline LorentzTensor::LorentzTensor(LorentzVector p, LorentzVector q) {
  for(int ix=0;ix<4;++ix) {
    for(int iy=0;iy<4;++iy) {
      _tensor[ix][iy]=p[ix]*q[iy];
    }
  }
}

// constructor specifying all components
inline LorentzTensor::
LorentzTensor(Complex xx, Complex xy, Complex xz, Complex xt,
	      Complex yx, Complex yy, Complex yz, Complex yt,
	      Complex zx, Complex zy, Complex zz, Complex zt,
	      Complex tx, Complex ty, Complex tz, Complex tt) {
  _tensor[0][0]=xx;_tensor[0][1]=xy;_tensor[0][2]=xz;_tensor[0][3]=xt;
  _tensor[1][0]=yx;_tensor[1][1]=yy;_tensor[1][2]=yz;_tensor[1][3]=yt;
  _tensor[2][0]=zx;_tensor[2][1]=zy;_tensor[2][2]=zz;_tensor[2][3]=zt;
  _tensor[3][0]=tx;_tensor[3][1]=ty;_tensor[3][2]=tz;_tensor[3][3]=tt;
}

inline LorentzTensor::~LorentzTensor() {}
// The destructor

inline Complex LorentzTensor::xx() const {return _tensor[0][0];}
inline Complex LorentzTensor::yx() const {return _tensor[1][0];}
inline Complex LorentzTensor::zx() const {return _tensor[2][0];}
inline Complex LorentzTensor::tx() const {return _tensor[3][0];}
inline Complex LorentzTensor::xy() const {return _tensor[0][1];}
inline Complex LorentzTensor::yy() const {return _tensor[1][1];}
inline Complex LorentzTensor::zy() const {return _tensor[2][1];}
inline Complex LorentzTensor::ty() const {return _tensor[3][1];}
inline Complex LorentzTensor::xz() const {return _tensor[0][2];}
inline Complex LorentzTensor::yz() const {return _tensor[1][2];}
inline Complex LorentzTensor::zz() const {return _tensor[2][2];}
inline Complex LorentzTensor::tz() const {return _tensor[3][2];}
inline Complex LorentzTensor::xt() const {return _tensor[0][3];}
inline Complex LorentzTensor::yt() const {return _tensor[1][3];}
inline Complex LorentzTensor::zt() const {return _tensor[2][3];}
inline Complex LorentzTensor::tt() const {return _tensor[3][3];}
// Get position and time.

inline void LorentzTensor::setXX(Complex a) {_tensor[0][0]=a;}
inline void LorentzTensor::setYX(Complex a) {_tensor[1][0]=a;}
inline void LorentzTensor::setZX(Complex a) {_tensor[2][0]=a;}
inline void LorentzTensor::setTX(Complex a) {_tensor[3][0]=a;}
inline void LorentzTensor::setXY(Complex a) {_tensor[0][1]=a;}
inline void LorentzTensor::setYY(Complex a) {_tensor[1][1]=a;}
inline void LorentzTensor::setZY(Complex a) {_tensor[2][1]=a;}
inline void LorentzTensor::setTY(Complex a) {_tensor[3][1]=a;}
inline void LorentzTensor::setXZ(Complex a) {_tensor[0][2]=a;}
inline void LorentzTensor::setYZ(Complex a) {_tensor[1][2]=a;}
inline void LorentzTensor::setZZ(Complex a) {_tensor[2][2]=a;}
inline void LorentzTensor::setTZ(Complex a) {_tensor[3][2]=a;}
inline void LorentzTensor::setXT(Complex a) {_tensor[0][3]=a;}
inline void LorentzTensor::setYT(Complex a) {_tensor[1][3]=a;}
inline void LorentzTensor::setZT(Complex a) {_tensor[2][3]=a;}
inline void LorentzTensor::setTT(Complex a) {_tensor[3][3]=a;}

// Set position and time
inline Complex LorentzTensor::operator () (int i,int j) const
{
  if( i>=0 && i<=3 && j>=0 && j<=3) return _tensor[i][j];
  throw HelicityLogicalError()
    << "Invalid component (" << i << "," << j
    << ") requested for LorentzTensor." << Exception::abortnow;
}

// Get components by index.
inline Complex & LorentzTensor::operator () (int i,int j)
{
  if( i>=0 && i<=3 && j>=0 && j<=3) return _tensor[i][j];
  throw HelicityLogicalError()
    << "Invalid component (" << i << "," << j
    << ") requested for LorentzTensor." << Exception::abortnow;
}

// Set components by index.
// Assignment
inline LorentzTensor & LorentzTensor::operator = (const LorentzTensor & q) {
  for(int ix=0;ix<4;++ix) {
    for(int iy=0;iy<4;++iy) _tensor[ix][iy]=q(ix,iy);
  }
  return *this;
}

// boost
inline LorentzTensor & LorentzTensor::boost(const Hep3Vector & b) {
  return boost(b.x(), b.y(), b.z());
}

// general lorentz transform
inline LorentzTensor & LorentzTensor::transform(const SpinOneLorentzRotation &r)
{
  unsigned int ix,iy,ixa,iya;
  LorentzTensor output;
  Complex temp;
  for(ix=0;ix<4;++ix)
    {for(iy=0;iy<4;++iy)
	{
	  temp=0.;
	  for(ixa=0;ixa<4;++ixa)
	    {for(iya=0;iya<4;++iya)
		{temp+=r(ix,ixa)*r(iy,iya)*(*this)(ixa,iya);}
	    }
	  output(ix,iy)=temp;
	}
    }
  *this=output;
  return *this;
}

inline LorentzTensor & LorentzTensor::transform(const LorentzRotation &r)
{
  SpinOneLorentzRotation one(r.one());
  transform(one);
  return *this;
}

inline LorentzTensor LorentzTensor::conjugate()
{
  return LorentzTensor(conj(xx()), conj(xy()), conj(xz()), conj(xt()),
		       conj(yx()), conj(yy()), conj(yz()), conj(yt()),
		       conj(zx()), conj(zy()), conj(zz()), conj(zt()),
		       conj(tx()), conj(ty()), conj(tz()), conj(tt()));
}

// product with another tensor
inline Complex LorentzTensor::operator * (const LorentzTensor & in) const
{
  Complex output=0.,temp;
  for(unsigned int ix=0;ix<4;++ix)
    {
      temp = _tensor[ix][3]*in._tensor[ix][3];
      for(unsigned int iy=0;iy<3;++iy)
	{
	  temp+=_tensor[ix][iy]*in._tensor[ix][iy];
	}
      if(ix<3){output-=temp;}
      else{output+=temp;}
    }
  return output;
}

// scaling with a complex number
inline LorentzTensor LorentzTensor::operator *= (Complex a)
{
  for(int ix=0;ix<4;++ix){for(int iy=0;iy<4;++iy){_tensor[ix][iy]*=a;}}
  return *this;
}

// multiplication by a complex number
inline LorentzTensor operator * (Complex a, const LorentzTensor & t)
{
  return LorentzTensor(a*t.xx(), a*t.xy(), a*t.xz(), a*t.xt(),
		       a*t.yx(), a*t.yy(), a*t.yz(), a*t.yt(),
		       a*t.zx(), a*t.zy(), a*t.zz(), a*t.zt(),
		       a*t.tx(), a*t.ty(), a*t.tz(), a*t.tt());
}
inline LorentzTensor LorentzTensor::operator + (const LorentzTensor & in) const
{
  return LorentzTensor(xx()+in.xx(),xy()+in.xy(),xz()+in.xz(),xt()+in.xt(),
		       yx()+in.yx(),yy()+in.yy(),yz()+in.yz(),yt()+in.yt(),
		       zx()+in.zx(),zy()+in.zy(),zz()+in.zz(),zt()+in.zt(),
		       tx()+in.tx(),ty()+in.ty(),tz()+in.tz(),tt()+in.tt());
}
inline LorentzTensor LorentzTensor::operator - (const LorentzTensor & in) const
{
  return LorentzTensor(xx()-in.xx(),xy()-in.xy(),xz()-in.xz(),xt()-in.xt(),
		       yx()-in.yx(),yy()-in.yy(),yz()-in.yz(),yt()-in.yt(),
		       zx()-in.zx(),zy()-in.zy(),zz()-in.zz(),zt()-in.zt(),
		       tx()-in.tx(),ty()-in.ty(),tz()-in.tz(),tt()-in.tt());
}

inline LorentzPolarizationVector operator * 
(const LorentzPolarizationVector & invec, const LorentzTensor & inten)
{
  LorentzPolarizationVector outvec;
  for(unsigned int ix=0;ix<4;++ix)
    {
      outvec[ix]=invec[3]*inten(3,ix)-invec[0]*inten(0,ix)
	-invec[1]*inten(1,ix)-invec[2]*inten(2,ix);
    }
  return outvec;
}
inline LorentzPolarizationVector operator * 
(const LorentzTensor & inten, const LorentzPolarizationVector & invec)
{
  LorentzPolarizationVector outvec;
  for(unsigned int ix=0;ix<4;++ix)
    {
      outvec[ix]=invec[3]*inten(ix,3)-invec[0]*inten(ix,0)
	-invec[1]*inten(ix,1)-invec[2]*inten(ix,2);
    }
  return outvec;
}

inline Complex LorentzTensor::trace()
{return _tensor[3][3]-_tensor[0][0]-_tensor[1][1]-_tensor[2][2];}

}
}

