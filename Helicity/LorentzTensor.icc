// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzTensor class.
//
// Author: Peter Richardson
//

#include "ThePEG/Helicity/HelicityDefinitions.h"

namespace ThePEG {
namespace Helicity {

// constructors
// default zero constructor
template <typename Value> inline LorentzTensor<Value>::LorentzTensor() {
  for(int ix=0;ix<4;++ix) {
    for(int iy=0;iy<4;++iy) {
      _tensor[ix][iy]=complex<Value>();
    }
  }
}

// constructor in terms of two polarization vectors
template <typename Value> inline LorentzTensor<Value>::
LorentzTensor(LorentzPolarizationVector p, LorentzPolarizationVector q) {
  setXX(p.x() * q.x());
  setYX(p.y() * q.x());
  setZX(p.z() * q.x());
  setTX(p.t() * q.x());
  setXY(p.x() * q.y());
  setYY(p.y() * q.y());
  setZY(p.z() * q.y());
  setTY(p.t() * q.y());
  setXZ(p.x() * q.z());
  setYZ(p.y() * q.z());
  setZZ(p.z() * q.z());
  setTZ(p.t() * q.z());
  setXT(p.x() * q.t());
  setYT(p.y() * q.t());
  setZT(p.z() * q.t());
  setTT(p.t() * q.t());
}

// // constructor in terms of two momenta
// template <typename Value> inline LorentzTensor<Value>::LorentzTensor(const LorentzVector<double> & p, 
// 				    const LorentzVector<double> & q) {
//   for(int ix=0;ix<4;++ix) {
//     for(int iy=0;iy<4;++iy) {
//       _tensor[ix][iy]=p[ix]*q[iy];
//     }
//   }
// }

// constructor specifying all components
template <typename Value> inline LorentzTensor<Value>::
LorentzTensor(complex<Value> xx, complex<Value> xy, complex<Value> xz, complex<Value> xt,
	      complex<Value> yx, complex<Value> yy, complex<Value> yz, complex<Value> yt,
	      complex<Value> zx, complex<Value> zy, complex<Value> zz, complex<Value> zt,
	      complex<Value> tx, complex<Value> ty, complex<Value> tz, complex<Value> tt) {
  _tensor[0][0]=xx;_tensor[0][1]=xy;_tensor[0][2]=xz;_tensor[0][3]=xt;
  _tensor[1][0]=yx;_tensor[1][1]=yy;_tensor[1][2]=yz;_tensor[1][3]=yt;
  _tensor[2][0]=zx;_tensor[2][1]=zy;_tensor[2][2]=zz;_tensor[2][3]=zt;
  _tensor[3][0]=tx;_tensor[3][1]=ty;_tensor[3][2]=tz;_tensor[3][3]=tt;
}

template <typename Value> inline LorentzTensor<Value>::~LorentzTensor<Value>() {}
// The destructor

template <typename Value> inline complex<Value> LorentzTensor<Value>::xx() const {return _tensor[0][0];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::yx() const {return _tensor[1][0];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::zx() const {return _tensor[2][0];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::tx() const {return _tensor[3][0];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::xy() const {return _tensor[0][1];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::yy() const {return _tensor[1][1];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::zy() const {return _tensor[2][1];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::ty() const {return _tensor[3][1];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::xz() const {return _tensor[0][2];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::yz() const {return _tensor[1][2];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::zz() const {return _tensor[2][2];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::tz() const {return _tensor[3][2];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::xt() const {return _tensor[0][3];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::yt() const {return _tensor[1][3];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::zt() const {return _tensor[2][3];}
template <typename Value> inline complex<Value> LorentzTensor<Value>::tt() const {return _tensor[3][3];}
// Get position and time.

template <typename Value> inline void LorentzTensor<Value>::setXX(complex<Value> a) {_tensor[0][0]=a;}
template <typename Value> inline void LorentzTensor<Value>::setYX(complex<Value> a) {_tensor[1][0]=a;}
template <typename Value> inline void LorentzTensor<Value>::setZX(complex<Value> a) {_tensor[2][0]=a;}
template <typename Value> inline void LorentzTensor<Value>::setTX(complex<Value> a) {_tensor[3][0]=a;}
template <typename Value> inline void LorentzTensor<Value>::setXY(complex<Value> a) {_tensor[0][1]=a;}
template <typename Value> inline void LorentzTensor<Value>::setYY(complex<Value> a) {_tensor[1][1]=a;}
template <typename Value> inline void LorentzTensor<Value>::setZY(complex<Value> a) {_tensor[2][1]=a;}
template <typename Value> inline void LorentzTensor<Value>::setTY(complex<Value> a) {_tensor[3][1]=a;}
template <typename Value> inline void LorentzTensor<Value>::setXZ(complex<Value> a) {_tensor[0][2]=a;}
template <typename Value> inline void LorentzTensor<Value>::setYZ(complex<Value> a) {_tensor[1][2]=a;}
template <typename Value> inline void LorentzTensor<Value>::setZZ(complex<Value> a) {_tensor[2][2]=a;}
template <typename Value> inline void LorentzTensor<Value>::setTZ(complex<Value> a) {_tensor[3][2]=a;}
template <typename Value> inline void LorentzTensor<Value>::setXT(complex<Value> a) {_tensor[0][3]=a;}
template <typename Value> inline void LorentzTensor<Value>::setYT(complex<Value> a) {_tensor[1][3]=a;}
template <typename Value> inline void LorentzTensor<Value>::setZT(complex<Value> a) {_tensor[2][3]=a;}
template <typename Value> inline void LorentzTensor<Value>::setTT(complex<Value> a) {_tensor[3][3]=a;}

// Set position and time
template <typename Value> inline complex<Value> LorentzTensor<Value>::operator () (int i,int j) const
{
  if( i>=0 && i<=3 && j>=0 && j<=3) return _tensor[i][j];
  throw HelicityLogicalError()
    << "Invalid component (" << i << "," << j
    << ") requested for LorentzTensor." << Exception::abortnow;
}

// Get components by index.
template <typename Value> inline complex<Value> & LorentzTensor<Value>::operator () (int i,int j)
{
  if( i>=0 && i<=3 && j>=0 && j<=3) return _tensor[i][j];
  throw HelicityLogicalError()
    << "Invalid component (" << i << "," << j
    << ") requested for LorentzTensor." << Exception::abortnow;
}

// Set components by index.
// Assignment
template <typename Value> inline LorentzTensor<Value> & LorentzTensor<Value>::operator = (const LorentzTensor<Value> & q) {
  for(int ix=0;ix<4;++ix) {
    for(int iy=0;iy<4;++iy) _tensor[ix][iy]=q(ix,iy);
  }
  return *this;
}

// boost
template <typename Value> inline LorentzTensor<Value> & LorentzTensor<Value>::boost(const Boost & b) {
  return boost(b.x(), b.y(), b.z());
}

// general lorentz transform
template <typename Value> inline LorentzTensor<Value> & LorentzTensor<Value>::transform(const SpinOneLorentzRotation &r)
{
  unsigned int ix,iy,ixa,iya;
  LorentzTensor<Value> output;
  complex<Value> temp;
  for(ix=0;ix<4;++ix)
    {for(iy=0;iy<4;++iy)
	{
	  temp=complex<Value>();
	  for(ixa=0;ixa<4;++ixa)
	    {for(iya=0;iya<4;++iya)
		{temp+=r(ix,ixa)*r(iy,iya)*(*this)(ixa,iya);}
	    }
	  output(ix,iy)=temp;
	}
    }
  *this=output;
  return *this;
}

template <typename Value> inline LorentzTensor<Value> LorentzTensor<Value>::conjugate()
{
  return LorentzTensor<Value>(conj(xx()), conj(xy()), conj(xz()), conj(xt()),
		       conj(yx()), conj(yy()), conj(yz()), conj(yt()),
		       conj(zx()), conj(zy()), conj(zz()), conj(zt()),
		       conj(tx()), conj(ty()), conj(tz()), conj(tt()));
}

// product with another tensor
template <typename T, typename U> 
inline complex<typename BinaryOpTraits<T,U>::MulT> 
operator*(const LorentzTensor<T> & t, const LorentzTensor<U> & u)
{
  typedef complex<typename BinaryOpTraits<T,U>::MulT> RetT;
  RetT output=RetT(),temp;
  for(unsigned int ix=0;ix<4;++ix)
    {
      temp = t._tensor[ix][3]*u._tensor[ix][3];
      for(unsigned int iy=0;iy<3;++iy)
	{
	  temp+= t._tensor[ix][iy]*u._tensor[ix][iy];
	}
      if(ix<3){output-=temp;}
      else{output+=temp;}
    }
  return output;
}

// scaling with a complex number
template <typename Value> inline LorentzTensor<Value> LorentzTensor<Value>::operator *= (Complex a)
{
  for(int ix=0;ix<4;++ix){for(int iy=0;iy<4;++iy){_tensor[ix][iy]*=a;}}
  return *this;
}

// multiplication by a complex number
template<typename T, typename U> 
inline LorentzTensor<typename BinaryOpTraits<T,U>::MulT> 
operator*(complex<U> a, const LorentzTensor<T> & t)
{
  return LorentzTensor<typename BinaryOpTraits<T,U>::MulT>
    (a*t.xx(), a*t.xy(), a*t.xz(), a*t.xt(),
     a*t.yx(), a*t.yy(), a*t.yz(), a*t.yt(),
     a*t.zx(), a*t.zy(), a*t.zz(), a*t.zt(),
     a*t.tx(), a*t.ty(), a*t.tz(), a*t.tt());
}
template <typename Value> inline LorentzTensor<Value> LorentzTensor<Value>::operator + (const LorentzTensor<Value> & in) const
{
  return LorentzTensor<Value>(xx()+in.xx(),xy()+in.xy(),xz()+in.xz(),xt()+in.xt(),
		       yx()+in.yx(),yy()+in.yy(),yz()+in.yz(),yt()+in.yt(),
		       zx()+in.zx(),zy()+in.zy(),zz()+in.zz(),zt()+in.zt(),
		       tx()+in.tx(),ty()+in.ty(),tz()+in.tz(),tt()+in.tt());
}
template <typename Value> inline LorentzTensor<Value> LorentzTensor<Value>::operator - (const LorentzTensor<Value> & in) const
{
  return LorentzTensor<Value>(xx()-in.xx(),xy()-in.xy(),xz()-in.xz(),xt()-in.xt(),
		       yx()-in.yx(),yy()-in.yy(),yz()-in.yz(),yt()-in.yt(),
		       zx()-in.zx(),zy()-in.zy(),zz()-in.zz(),zt()-in.zt(),
		       tx()-in.tx(),ty()-in.ty(),tz()-in.tz(),tt()-in.tt());
}

template<typename T, typename U> 
inline LorentzVector<typename BinaryOpTraits<complex<T>,U>::MulT>
operator*(const LorentzVector<U> & invec, const LorentzTensor<T> & inten)
{
  LorentzVector<typename BinaryOpTraits<complex<T>,U>::MulT> outvec;
  outvec.setX(invec.t()*inten(3,0)-invec.x()*inten(0,0)
	      -invec.y()*inten(1,0)-invec.z()*inten(2,0));
  outvec.setY(invec.t()*inten(3,1)-invec.x()*inten(0,1)
	      -invec.y()*inten(1,1)-invec.z()*inten(2,1));
  outvec.setZ(invec.t()*inten(3,2)-invec.x()*inten(0,2)
	      -invec.y()*inten(1,2)-invec.z()*inten(2,2));
  outvec.setT(invec.t()*inten(3,3)-invec.x()*inten(0,3)
	      -invec.y()*inten(1,3)-invec.z()*inten(2,3));
  return outvec;
}

template<typename T, typename U> 
inline LorentzVector<typename BinaryOpTraits<complex<T>,U>::MulT>
operator*(const LorentzTensor<T> & inten, const LorentzVector<U> & invec)
{
  LorentzVector<typename BinaryOpTraits<complex<T>,U>::MulT> outvec;
  outvec.setX(invec.t()*inten(0,3)-invec.x()*inten(0,0)
	      -invec.y()*inten(0,1)-invec.z()*inten(0,2));
  outvec.setY(invec.t()*inten(1,3)-invec.x()*inten(1,0)
	      -invec.y()*inten(1,1)-invec.z()*inten(1,2));
  outvec.setZ(invec.t()*inten(2,3)-invec.x()*inten(2,0)
	      -invec.y()*inten(2,1)-invec.z()*inten(2,2));
  outvec.setT(invec.t()*inten(3,3)-invec.x()*inten(3,0)
	      -invec.y()*inten(3,1)-invec.z()*inten(3,2));
  return outvec;
}

template <typename Value> inline complex<Value> LorentzTensor<Value>::trace()
{return _tensor[3][3]-_tensor[0][0]-_tensor[1][1]-_tensor[2][2];}

}
}

