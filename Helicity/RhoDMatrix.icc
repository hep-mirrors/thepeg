// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the RhoDMatrix class.
//
// Author: Peter Richardson
//

#include "ThePEG/Helicity/HelicityDefinitions.h"

namespace ThePEG {
namespace Helicity {

inline RhoDMatrix::RhoDMatrix(PDT::Spin inspin)
  :  _spin(inspin), _ispin(), _matrix(5,vector<Complex>(5))
{
  if(inspin<1||inspin>5) throw HelicityLogicalError()
    << "Invalid spin for a RhoDMatrix " << inspin <<  Exception::abortnow;
  _ispin=abs(int(inspin));
}

inline RhoDMatrix::RhoDMatrix()
  : _spin(), _ispin(), _matrix(5,vector<Complex>(5)) {}

inline Complex RhoDMatrix::operator () (unsigned int ix,unsigned int iy) const
  // operator to return an element of the matrix
{
  if(ix>_ispin) throw HelicityLogicalError()
    << "Invalid 1st index called for RhoDMatrix " << ix
    << "   " << _ispin << Exception::abortnow;
  if(iy>_ispin) throw HelicityLogicalError()
    << "Invalid 2nd index called for RhoDMatrix " << iy
    << "   " << _ispin << Exception::abortnow;
  return _matrix[ix][iy];
}

inline Complex & RhoDMatrix::operator () (unsigned int ix,unsigned int iy)
  // operator to return an element of the matrix
{
  if(ix>_ispin) throw HelicityLogicalError()
    << "Invalid 1st index called for RhoDMatrix " << ix
    << "   " << _ispin << Exception::abortnow;
  if(iy>_ispin) throw HelicityLogicalError()
    << "Invalid 2nd index called for RhoDMatrix " << iy
    << "   " << _ispin << Exception::abortnow;
  return _matrix[ix][iy];
}
  
// set the spin
inline PDT::Spin RhoDMatrix::iSpin(PDT::Spin inspin)
{
  if(inspin<1||inspin>5) throw HelicityLogicalError()
    << "Invalid spin for a RhoDMatrix " << inspin <<  Exception::abortnow;
  _spin=inspin;
  _ispin=abs(int(_spin));
  return _spin;
 }

// get the spin
inline PDT::Spin RhoDMatrix::iSpin() const { return _spin;}

// set the matrix to 1/(2s+1) on diagonals and zero elsewhere
inline void RhoDMatrix::average()
{
  unsigned int ix,iy;
  for(ix=0;ix<_ispin;++ix)
    {
      for(iy=0;iy<_ispin;++iy){_matrix[ix][iy]=0.;}
      _matrix[ix][ix]=1./_ispin;
    }
}

inline void RhoDMatrix::normalize()
{
  static double epsa=1e-30,epsb=1e-10;
  unsigned int ix,iy;
  Complex norm=0;
  for(ix=0;ix<5&&ix<_ispin;++ix){norm+=_matrix[ix][ix];}
  if ( norm.real() < epsa ) throw HelicityConsistencyError()
    << "RhoDMatrix::normalize() the trace is too small "
    << norm.real() << Exception::maybeabort;
  if ( norm.imag()/norm.real() > epsb ) throw HelicityConsistencyError()
    << "RhoDMatrix::normalize() the imaginary part of the trace is too large"
    << norm.imag() << Exception::maybeabort;
  norm=1./norm;
  for(ix=0;ix<5&&ix<_ispin;++ix)
    for(iy=0;iy<5&&iy<_ispin;++iy) _matrix[ix][iy]*=norm;
}

inline void RhoDMatrix::output()
{
  unsigned int ix,iy;
  for(ix=0;ix<5&&ix<_ispin;++ix)
    {
      for(iy=0;ix<5&&iy<_ispin;++iy){cout << _matrix[ix][iy] << "  ";}
      cout << endl;
    }
}

inline void RhoDMatrix::zero()
{
  unsigned int ix,iy;
  for(ix=0;ix<5&&ix<_ispin;++ix)
    {
      for(iy=0;ix<5&&iy<_ispin;++iy){_matrix[ix][iy]=0.;}}
}

}
}

