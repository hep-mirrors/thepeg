// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzSpinorBar class.
//
// Author: Peter Richardson
//

namespace ThePEG {
namespace Helicity {

// inlined function of the LorentzSpinorBar class
// default zero constructor
inline LorentzSpinorBar::LorentzSpinorBar(DiracRep dirac) {
  _dirac=dirac;
  _type=unknown_spinortype;
  for(int ix=0;ix<4;++ix){
    _spin[ix]=0.;
  }
}

inline LorentzSpinorBar::LorentzSpinorBar(SpinorType type, DiracRep dirac) {
  _dirac=dirac;
  _type=type;
  for(int ix=0;ix<4;++ix){
    _spin[ix]=0.;
  }
}

// constructor with complex numbers

inline LorentzSpinorBar::
LorentzSpinorBar(Complex a,Complex b, Complex c,Complex d,DiracRep dirac) {
  _dirac=dirac;
  _type=unknown_spinortype;
  _spin[0]=a;
  _spin[1]=b;
  _spin[2]=c;
  _spin[3]=d;
}

inline LorentzSpinorBar::
LorentzSpinorBar(Complex a,Complex b, Complex c,Complex d,SpinorType type,
		 DiracRep dirac) {
  _dirac=dirac;
  _type=type;
  _spin[0]=a;
  _spin[1]=b;
  _spin[2]=c;
  _spin[3]=d;
}

// subscript operator to return spinor components
inline Complex LorentzSpinorBar::operator[](int i) const
{
  if ( i >= 0 && i <= 3 ) return _spin[i];
  else throw HelicityLogicalError()
    << "Invalid component of LorentzSpinorBar requested. Component:" << i
    << Exception::abortnow;
}

inline Complex LorentzSpinorBar::operator()(int i) const
{
  if ( i >= 0 && i <= 3 ) return _spin[i];
  else throw HelicityLogicalError()
    << "Invalid component of LorentzSpinorBar Requested. Component:" << i
    << Exception::abortnow;
}

// set components by index
inline Complex & LorentzSpinorBar::operator () (int i){
  if ( i>= 0 && i <= 3 ) return _spin[i];
  throw HelicityLogicalError()
    << "Invalid index " << i << " called for LorentzSpinorBar."
    << Exception::abortnow;
}

inline Complex & LorentzSpinorBar::operator [] (int i){
  if ( i >= 0 && i <=3 ) return _spin[i];
  throw HelicityLogicalError()
    << "Invalid index " << i << " called for LorentzSpinorBar."
    << Exception::abortnow;
}

// Get components
inline Complex LorentzSpinorBar::s1() const {return _spin[0];}
inline Complex LorentzSpinorBar::s2() const {return _spin[1];}
inline Complex LorentzSpinorBar::s3() const {return _spin[2];}
inline Complex LorentzSpinorBar::s4() const {return _spin[3];}

// Set components
inline void LorentzSpinorBar::setS1(Complex in){_spin[0]=in;}
inline void LorentzSpinorBar::setS2(Complex in){_spin[1]=in;}
inline void LorentzSpinorBar::setS3(Complex in){_spin[2]=in;}
inline void LorentzSpinorBar::setS4(Complex in){_spin[3]=in;}

// the assignment operator
inline LorentzSpinorBar & LorentzSpinorBar::operator = (const LorentzSpinorBar & in) {
  _dirac=in._dirac;
  _type=in._type;
  _spin[0]=in.s1();
  _spin[1]=in.s2();
  _spin[2]=in.s3();
  _spin[3]=in.s4();
  return *this;
}

// change the dirac matrix representation
inline void LorentzSpinorBar::changeRep(DiracRep newdirac) {
  if(newdirac!=_dirac) *this = transformRep(newdirac);
}

// return the spinor in a different representation
inline LorentzSpinorBar LorentzSpinorBar::transformRep(DiracRep newdirac) const {
  // do nothing if all ready in the correct representation
  if(newdirac==_dirac){return *this;}
  double fact=1./sqrt(2.);
  // transform from HELAS representation to Haber one
  Complex output[4];
  if(newdirac==HELASDRep && _dirac==HaberDRep) {
    output[0] = fact*( _spin[0]-_spin[2]);
    output[1] = fact*( _spin[1]-_spin[3]);
    output[2] = fact*( _spin[0]+_spin[2]);
    output[3] = fact*( _spin[1]+_spin[3]);
  }
  // transform from Haber representation to HELAS one
  else if(newdirac==HaberDRep && _dirac==HELASDRep) {
    output[0] = fact*( _spin[0]+_spin[2]);
    output[1] = fact*( _spin[1]+_spin[3]);
    output[2] = fact*(-_spin[0]+_spin[2]);
    output[3] = fact*(-_spin[1]+_spin[3]);
  }
  // return the answer
  return LorentzSpinorBar(output[0],output[1],output[2],output[3],_type,newdirac);
}

// return the representation of the spinor
inline const DiracRep LorentzSpinorBar::Rep() const {
  return _dirac;
}

// return thetype of the spinor
inline const SpinorType LorentzSpinorBar::Type() const {
  return _type;
}

inline LorentzSpinorBar & LorentzSpinorBar::transform(const LorentzRotation & r) {
  SpinHalfLorentzRotation half(r.half());
  transform(half);
  return *this;
}
}
}
