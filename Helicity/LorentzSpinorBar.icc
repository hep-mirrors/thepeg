// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the LorentzSpinorBar class.
//
// Author: Peter Richardson
//

#include "ThePEG/Helicity/HelicityDefinitions.h"

namespace ThePEG {
namespace Helicity {

// inlined function of the LorentzSpinorBar class
// default zero constructor
inline LorentzSpinorBar::LorentzSpinorBar() {
  _idirac=HelicityDefinitions::getDirac();
  _itype=0;
  for(int ix=0;ix<4;++ix){_spin[ix]=0.;}
}
inline LorentzSpinorBar::LorentzSpinorBar(int type) {
  _idirac=HelicityDefinitions::getDirac();
  _itype=type;
  for(int ix=0;ix<4;++ix){
    _spin[ix]=0.;
  }
}
inline LorentzSpinorBar::LorentzSpinorBar(int dirac, int type) {
  _idirac=dirac;
  _itype=type;
  for(int ix=0;ix<4;++ix){
    _spin[ix]=0.;
  }
}

// constructor with complex numbers
inline LorentzSpinorBar::
LorentzSpinorBar(int type,Complex a,Complex b, Complex c,Complex d) {
  _idirac=HelicityDefinitions::getDirac();
  _itype=type;
  _spin[0]=a;
  _spin[1]=b;
  _spin[2]=c;
  _spin[3]=d;
}
// constructor with complex numbers
inline LorentzSpinorBar::
LorentzSpinorBar(int dirac, int type,Complex a,Complex b, Complex c,Complex d) {
  _idirac=dirac;
  _itype=type;
  _spin[0]=a;
  _spin[1]=b;
  _spin[2]=c;
  _spin[3]=d;
}

// subscript operator to return spinor components
inline Complex LorentzSpinorBar::operator[](int i) const
{
  if ( i >= 0 && i <= 3 ) return _spin[i];
  else throw HelicityLogicalError()
    << "Invalid component of LorentzSpinorBar requested. Component:" << i
    << Exception::abortnow;
}

inline Complex LorentzSpinorBar::operator()(int i) const
{
  if ( i >= 0 && i <= 3 ) return _spin[i];
  else throw HelicityLogicalError()
    << "Invalid component of LorentzSpinorBar Requested. Component:" << i
    << Exception::abortnow;
}

// set components by index
inline Complex & LorentzSpinorBar::operator () (int i){
  if ( i>= 0 && i <= 3 ) return _spin[i];
  throw HelicityLogicalError()
    << "Invalid index " << i << " called for LorentzSpinorBar."
    << Exception::abortnow;
}

inline Complex & LorentzSpinorBar::operator [] (int i){
  if ( i >= 0 && i <=3 ) return _spin[i];
  throw HelicityLogicalError()
    << "Invalid index " << i << " called for LorentzSpinorBar."
    << Exception::abortnow;
}

// Get components
inline Complex LorentzSpinorBar::s1() const {return _spin[0];}
inline Complex LorentzSpinorBar::s2() const {return _spin[1];}
inline Complex LorentzSpinorBar::s3() const {return _spin[2];}
inline Complex LorentzSpinorBar::s4() const {return _spin[3];}

// Set components
inline void LorentzSpinorBar::setS1(Complex in){_spin[0]=in;}
inline void LorentzSpinorBar::setS2(Complex in){_spin[1]=in;}
inline void LorentzSpinorBar::setS3(Complex in){_spin[2]=in;}
inline void LorentzSpinorBar::setS4(Complex in){_spin[3]=in;}

// the assignment operator
inline LorentzSpinorBar & LorentzSpinorBar::
operator = (const LorentzSpinorBar & in) {
  _idirac=in._idirac;
  _itype=in._itype;
  _spin[0]=in.s1();
  _spin[1]=in.s2();
  _spin[2]=in.s3();
  _spin[3]=in.s4();
  return *this;
}

inline LorentzSpinorBar LorentzSpinorBar::
boost(double bx,double by,double bz) const
{
  // work out beta and chi
  double beta=sqrt(bx*bx+by*by+bz*bz);
  double chi = atanh(beta);
  double sinhchi = sinh(0.5*chi)/beta, coshchi = cosh(0.5*chi);
  // calculate the new spinor
  Complex out[4],ii(0.,1.);
  Complex nxminy=bx-ii*by;
  Complex nxpiny=bx+ii*by;
  switch(_idirac)
    {
      // Haber lower energy
    case 1:
      out[0] = coshchi*_spin[0]+sinhchi*(+bz*_spin[2]+nxpiny*_spin[3]);
      out[1] = coshchi*_spin[1]+sinhchi*(-bz*_spin[3]+nxminy*_spin[2]);
      out[2] = coshchi*_spin[2]+sinhchi*(+bz*_spin[0]+nxpiny*_spin[1]);
      out[3] = coshchi*_spin[3]+sinhchi*(-bz*_spin[1]+nxminy*_spin[0]);
      break;
      // HELAS
    case 2:
      out[0] = coshchi*_spin[0]+sinhchi*(-bz*_spin[0]-nxpiny*_spin[1]);
      out[1] = coshchi*_spin[1]+sinhchi*(+bz*_spin[1]-nxminy*_spin[0]);
      out[2] = coshchi*_spin[2]+sinhchi*(+bz*_spin[2]+nxpiny*_spin[3]);
      out[3] = coshchi*_spin[3]+sinhchi*(-bz*_spin[3]+nxminy*_spin[2]);
      break;
    }
  return LorentzSpinorBar(_idirac,_itype,out[0],out[1],out[2],out[3]);
}

inline LorentzSpinorBar LorentzSpinorBar::
boost(const Hep3Vector & boostv) const
{
  double beta = boostv.mag();
  double bx=boostv.x(),by=boostv.y(),bz=boostv.z();
  double chi = atanh(beta);
  double sinhchi = sinh(0.5*chi)/beta, coshchi = cosh(0.5*chi);
  Complex out[4],ii(0.,1.);
  Complex nxminy=bx-ii*by;
  Complex nxpiny=bx+ii*by;
  switch(_idirac)
    {
      // Haber lower energy
    case 1:
      out[0] = coshchi*_spin[0]+sinhchi*(+bz*_spin[2]+nxpiny*_spin[3]);
      out[1] = coshchi*_spin[1]+sinhchi*(-bz*_spin[3]+nxminy*_spin[2]);
      out[2] = coshchi*_spin[2]+sinhchi*(+bz*_spin[0]+nxpiny*_spin[1]);
      out[3] = coshchi*_spin[3]+sinhchi*(-bz*_spin[1]+nxminy*_spin[0]);
      break;
      // HELAS
    case 2:
      out[0] = coshchi*_spin[0]+sinhchi*(-bz*_spin[0]-nxpiny*_spin[1]);
      out[1] = coshchi*_spin[1]+sinhchi*(+bz*_spin[1]-nxminy*_spin[0]);
      out[2] = coshchi*_spin[2]+sinhchi*(+bz*_spin[2]+nxpiny*_spin[3]);
      out[3] = coshchi*_spin[3]+sinhchi*(-bz*_spin[3]+nxminy*_spin[2]);
      break;
    }
  return LorentzSpinorBar(_idirac,_itype,out[0],out[1],out[2],out[3]);
}

// change the dirac matrix representation
inline void LorentzSpinorBar::changeRep(int newdirac)
{
  // do nothing if all ready in the correct representation
  if(newdirac==_idirac){return;}
  double fact=1./sqrt(2.);
  // transform from HELAS representation to Haber one
  Complex output[4];
  if(newdirac==2 && _idirac==1)
    {
      output[0] = fact*( _spin[0]-_spin[2]);
      output[1] = fact*( _spin[1]-_spin[3]);
      output[2] = fact*( _spin[0]+_spin[2]);
      output[3] = fact*( _spin[1]+_spin[3]);
    }
  // transform from Haber representation to HELAS one
  else if(newdirac==1 && _idirac==2)
    {
      output[0] = fact*( _spin[0]+_spin[2]);
      output[1] = fact*( _spin[1]+_spin[3]);
      output[2] = fact*(-_spin[0]+_spin[2]);
      output[3] = fact*(-_spin[1]+_spin[3]);
    }
  // invalid choice
  else
    {
      cerr << "invalid transformation for LorentzSpinor" << endl;
      return;
    }
  // reset the spinor
  _idirac=newdirac;
  for(unsigned int ix=0;ix<4;++ix){_spin[ix]=output[ix];}
}


// return the spinor in a different representation
inline LorentzSpinorBar LorentzSpinorBar::transformRep(int newdirac)
{
  // do nothing if all ready in the correct representation
  if(newdirac==_idirac){return *this;}
  double fact=1./sqrt(2.);
  // transform from HELAS representation to Haber one
  Complex output[4];
  if(newdirac==2 && _idirac==1)
    {
      output[0] = fact*( _spin[0]-_spin[2]);
      output[1] = fact*( _spin[1]-_spin[3]);
      output[2] = fact*( _spin[0]+_spin[2]);
      output[3] = fact*( _spin[1]+_spin[3]);
    }
  // transform from Haber representation to HELAS one
  else if(newdirac==1 && _idirac==2)
    {
      output[0] = fact*( _spin[0]+_spin[2]);
      output[1] = fact*( _spin[1]+_spin[3]);
      output[2] = fact*(-_spin[0]+_spin[2]);
      output[3] = fact*(-_spin[1]+_spin[3]);
    }
  // invalid choice
  else
    {
      cerr << "invalid transformation for LorentzSpinor" << endl;
      return *this;
    }
  // return the answer
  return LorentzSpinorBar(newdirac,_itype,output[0],output[1],output[2],output[3]);
}

// return the representation of the spinor
inline int LorentzSpinorBar::Rep(){return _idirac;}
}
}
