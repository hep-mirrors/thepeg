// -*- C++ -*-
//
// LorentzSpinorBar.icc is a part of ThePEG - Toolkit for HEP Event Generation
// Copyright (C) 2003-2007 Peter Richardson, Leif Lonnblad
//
// ThePEG is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the LorentzSpinorBar class.
//
// Author: Peter Richardson
//

namespace ThePEG {
namespace Helicity {

// inlined function of the LorentzSpinorBar class
// default zero constructor
template <typename Value> inline LorentzSpinorBar<Value>::LorentzSpinorBar(DiracRep dirac) 
  : _dirac(dirac), _type(unknown_spinortype), _spin(4) {}

template <typename Value> inline LorentzSpinorBar<Value>::LorentzSpinorBar(SpinorType type, DiracRep dirac) 
  : _dirac(dirac), _type(type), _spin(4) {}

// constructor with complex numbers

template <typename Value> inline LorentzSpinorBar<Value>::
LorentzSpinorBar(complex<Value> a,complex<Value> b, complex<Value> c,complex<Value> d,DiracRep dirac) 
  : _dirac(dirac), _type(unknown_spinortype), _spin(4) {
  _spin[0]=a;
  _spin[1]=b;
  _spin[2]=c;
  _spin[3]=d;
}

template <typename Value> inline LorentzSpinorBar<Value>::
LorentzSpinorBar(complex<Value> a,complex<Value> b, complex<Value> c,complex<Value> d,SpinorType type,
		 DiracRep dirac) 
  : _dirac(dirac), _type(type), _spin(4) {
  _spin[0]=a;
  _spin[1]=b;
  _spin[2]=c;
  _spin[3]=d;
}

// subscript operator to return spinor components
template <typename Value> 
inline complex<Value> LorentzSpinorBar<Value>::operator[](int i) const
{
  if ( i >= 0 && i <= 3 ) return _spin[i];
  else throw HelicityLogicalError()
    << "Invalid component of LorentzSpinorBar requested. Component:" << i
    << Exception::abortnow;
}

template <typename Value> inline complex<Value> LorentzSpinorBar<Value>::operator()(int i) const
{
  if ( i >= 0 && i <= 3 ) return _spin[i];
  else throw HelicityLogicalError()
    << "Invalid component of LorentzSpinorBar Requested. Component:" << i
    << Exception::abortnow;
}

// set components by index
template <typename Value> inline complex<Value> & LorentzSpinorBar<Value>::operator () (int i){
  if ( i>= 0 && i <= 3 ) return _spin[i];
  throw HelicityLogicalError()
    << "Invalid index " << i << " called for LorentzSpinorBar."
    << Exception::abortnow;
}

template <typename Value> inline complex<Value> & LorentzSpinorBar<Value>::operator [] (int i){
  if ( i >= 0 && i <=3 ) return _spin[i];
  throw HelicityLogicalError()
    << "Invalid index " << i << " called for LorentzSpinorBar."
    << Exception::abortnow;
}

// Get components
template <typename Value> inline complex<Value> LorentzSpinorBar<Value>::s1() const {return _spin[0];}
template <typename Value> inline complex<Value> LorentzSpinorBar<Value>::s2() const {return _spin[1];}
template <typename Value> inline complex<Value> LorentzSpinorBar<Value>::s3() const {return _spin[2];}
template <typename Value> inline complex<Value> LorentzSpinorBar<Value>::s4() const {return _spin[3];}

// Set components
template <typename Value> inline void LorentzSpinorBar<Value>::setS1(complex<Value> in){_spin[0]=in;}
template <typename Value> inline void LorentzSpinorBar<Value>::setS2(complex<Value> in){_spin[1]=in;}
template <typename Value> inline void LorentzSpinorBar<Value>::setS3(complex<Value> in){_spin[2]=in;}
template <typename Value> inline void LorentzSpinorBar<Value>::setS4(complex<Value> in){_spin[3]=in;}

// change the dirac matrix representation
template <typename Value> 
inline void LorentzSpinorBar<Value>::changeRep(DiracRep newdirac)
{
  if(newdirac!=_dirac) *this = transformRep(newdirac);
}

// return the spinor in a different representation
template <typename Value> 
inline LorentzSpinorBar<Value> 
LorentzSpinorBar<Value>::transformRep(DiracRep newdirac) const
{
  // do nothing if all ready in the correct representation
  if(newdirac==_dirac){return *this;}
  double fact=1./sqrt(2.);
  // transform from HELAS representation to Haber one
  complex<Value> output[4];
  if(newdirac==HELASDRep && _dirac==HaberDRep) {
    output[0] = fact*( _spin[0]-_spin[2]);
    output[1] = fact*( _spin[1]-_spin[3]);
    output[2] = fact*( _spin[0]+_spin[2]);
    output[3] = fact*( _spin[1]+_spin[3]);
  }
  // transform from Haber representation to HELAS one
  else if(newdirac==HaberDRep && _dirac==HELASDRep) {
    output[0] = fact*( _spin[0]+_spin[2]);
    output[1] = fact*( _spin[1]+_spin[3]);
    output[2] = fact*(-_spin[0]+_spin[2]);
    output[3] = fact*(-_spin[1]+_spin[3]);
  }
  // return the answer
  return LorentzSpinorBar(output[0],output[1],output[2],output[3],_type,newdirac);
}

// return the representation of the spinor
template <typename Value> 
inline DiracRep 
LorentzSpinorBar<Value>::Rep() const {
  return _dirac;
}

// return thetype of the spinor
template <typename Value> 
inline SpinorType 
LorentzSpinorBar<Value>::Type() const {
  return _type;
}

template <typename Value> 
inline LorentzSpinorBar<Value> & 
LorentzSpinorBar<Value>::transform(const LorentzRotation & r)
{
  SpinHalfLorentzRotation half(r.half());
  transform(half);
  return *this;
}
}
}
