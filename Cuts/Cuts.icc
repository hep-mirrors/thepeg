// -*- C++ -*-
//
// Cuts.icc is a part of ThePEG - Toolkit for HEP Event Generation
// Copyright (C) 1999-2007 Leif Lonnblad
//
// ThePEG is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the Cuts class.
//

namespace ThePEG {

inline Cuts::Cuts()
  : theSMax(0.0*GeV2), theY(0), theCurrentSHat(-1.0*GeV2),
    theCurrentYHat(0), theMHatMin(2.0*GeV), theMHatMax(Constants::MaxEnergy),
    theYHatMin(-Constants::MaxRapidity), theYHatMax(Constants::MaxRapidity),
    theX1Min(0.0), theX1Max(1.0), theX2Min(0.0), theX2Max(1.0),
    theScaleMin(0.0*GeV2), theScaleMax(Constants::MaxEnergy2) {}

inline Cuts::Cuts(const Cuts & x)
  : Interfaced(x), theSMax(x.theSMax), theY(x.theY),
    theCurrentSHat(x.theCurrentSHat), theCurrentYHat(x.theCurrentYHat),
    theMHatMin(x.theMHatMin), theMHatMax(x.theMHatMax),
    theYHatMin(x.theYHatMin), theYHatMax(x.theYHatMax),
    theX1Min(x.theX1Min), theX1Max(x.theX1Max),
    theX2Min(x.theX2Min), theX2Max(x.theX2Max),
    theScaleMin(x.theScaleMin), theScaleMax(x.theScaleMax),
    theOneCuts(x.theOneCuts), theTwoCuts(x.theTwoCuts),
    theMultiCuts(x.theMultiCuts) {}

inline Energy2 Cuts::SMax() const {
  return theSMax;
}

inline double Cuts::Y() const {
  return theY;
}

inline Energy2 Cuts::currentSHat() const {
  return theCurrentSHat;
}

inline double Cuts::currentYHat() const {
  return theCurrentYHat;
}

inline Energy2 Cuts::sHatMin() const {
  return max(sqr(theMHatMin), theX1Min*theX2Min*SMax());
}

inline Energy2 Cuts::sHatMax() const {
  return min(sqr(theMHatMax), theX1Max*theX2Max*SMax());
}

inline bool Cuts::sHat(Energy2 sh) const {
  return sh > sHatMin() && sh <= sHatMax();
}

inline Energy Cuts::mHatMin() const {
  return max(theMHatMin, sqrt(theX1Min*theX2Min*SMax()));
}

inline Energy Cuts::mHatMax() const {
  return min(theMHatMax, sqrt(theX1Max*theX2Max*SMax()));
}

inline Energy2 Cuts::scaleMin() const {
  return theScaleMin;
}

inline Energy2 Cuts::scaleMax() const {
  return theScaleMax;
}

inline bool Cuts::scale(Energy2 Q2) const {
  return Q2 > scaleMin() && Q2 < scaleMax();
}

inline double Cuts::yHatMin() const {
  return theX1Min > 0.0 && theX2Max > 0.0?
    max(theYHatMin, 0.5*log(theX1Min/theX2Max)): theYHatMin;
}

inline double Cuts::yHatMax() const {
  return theX1Max > 0.0 && theX2Min > 0.0?
    min(theYHatMax, 0.5*log(theX1Max/theX2Min)): theYHatMax;
}

inline bool Cuts::yHat(double y) const {
  return y > yHatMin() && y < yHatMax();
}

inline double Cuts::x1Min() const {
  return max(theX1Min, (theMHatMin/sqrt(SMax()))*exp(theYHatMin));
}

inline double Cuts::x1Max() const {
  return min(theX1Max, (theMHatMax/sqrt(SMax()))*exp(theYHatMax));
}

inline bool Cuts::x1(double x) const {
  return x > x1Min() && x <= x1Max();
}

inline double Cuts::x2Min() const {
  return max(theX2Min, (theMHatMin/sqrt(SMax()))/exp(theYHatMax));
}

inline double Cuts::x2Max() const {
  return min(theX2Max, (theMHatMax/sqrt(SMax()))/exp(theYHatMin));
}

inline bool Cuts::x2(double x) const {
  return x > x2Min() && x <= x2Max();
}

template <typename T>
vector<typename Ptr<T>::transient_const_pointer>
Cuts::oneCutObjects() const {
  typedef typename Ptr<T>::transient_const_pointer tcPtr;
  vector<tcPtr> ret;
  for ( int i = 0, N = theOneCuts.size(); i < N; ++i )
    if ( dynamic_ptr_cast<tcPtr>(theOneCuts[i]) )
      ret.push_back(dynamic_ptr_cast<tcPtr>(theOneCuts[i]));
  return ret;
}

template <typename T>
vector<typename Ptr<T>::transient_const_pointer>
Cuts::twoCutObjects() const {
  typedef typename Ptr<T>::transient_const_pointer tcPtr;
  vector<tcPtr> ret;
  for ( int i = 0, N = theTwoCuts.size(); i < N; ++i )
    if ( dynamic_ptr_cast<tcPtr>(theTwoCuts[i]) )
      ret.push_back(dynamic_ptr_cast<tcPtr>(theTwoCuts[i]));
  return ret;
}

template <typename T>
vector<typename Ptr<T>::transient_const_pointer>
Cuts::multiCutObjects() const {
  typedef typename Ptr<T>::transient_const_pointer tcPtr;
  vector<tcPtr> ret;
  for ( int i = 0, N = theMultiCuts.size(); i < N; ++i )
    if ( dynamic_ptr_cast<tcPtr>(theMultiCuts[i]) )
      ret.push_back(dynamic_ptr_cast<tcPtr>(theMultiCuts[i]));
  return ret;
}

inline IBPtr Cuts::clone() const {
  return new_ptr(*this);
}

inline IBPtr Cuts::fullclone() const {
  return new_ptr(*this);
}

inline void Cuts::doupdate() throw(UpdateException) {
  Interfaced::doupdate();
}

inline void Cuts::doinit() throw(InitException) {
  Interfaced::doinit();
}

inline void Cuts::dofinish() {
  Interfaced::dofinish();
}

inline void Cuts::doinitrun() {
  Interfaced::doinitrun();
}

inline void Cuts::rebind(const TranslationMap & trans)
  throw(RebindException) {
  Interfaced::rebind(trans);
}

inline IVector Cuts::getReferences() {
  IVector ret = Interfaced::getReferences();
  return ret;
}

}
