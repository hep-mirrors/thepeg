// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the ObjectIndexer class.
//

namespace ThePEG {

template <typename IntT, typename ObjT>
inline IntT ObjectIndexer<IntT,ObjT>::operator()(tTPtr o) {
  typename ObjectIndexMap::iterator it = objectIndex.find(o);
  if ( it == objectIndex.end() ) {
    IntT i = 0;
    while ( indexObject.find(i) != indexObject.end() ) ++i;
    objectIndex[o] = i;
    indexObject[i] = o;
    return i;
  } else
    return it->second;
}

template <typename IntT, typename ObjT>
inline typename ObjectIndexer<IntT,ObjT>::tTPtr
ObjectIndexer<IntT,ObjT>::operator()(IntT i) {
  typename IndexObjectMap::iterator it = indexObject.find(i);
  if ( it == indexObject.end() ) {
    TPtr o = new_ptr<ObjT>();
    objectIndex[o] = i;
    indexObject[i] = o;
    return o;
  } else
    return it->second;
}

template <typename IntT, typename ObjT>
inline typename ObjectIndexer<IntT,ObjT>::tTPtr
ObjectIndexer<IntT,ObjT>::operator()(IntT i) const {
  typename IndexObjectMap::const_iterator it = indexObject.find(i);
  return it == indexObject.end()? tTPtr(): it->second;
}

template <typename IntT, typename ObjT>
inline void ObjectIndexer<IntT,ObjT>::operator()(IntT i, tTPtr o) {
  typename IndexObjectMap::iterator iit = indexObject.find(i);
  if ( iit != indexObject.end() ) objectIndex.erase(iit->second);
  typename ObjectIndexMap::iterator oit = objectIndex.find(o);
  if ( oit != objectIndex.end() ) indexObject.erase(oit->second);
  objectIndex[o] = i;
  indexObject[i] = o;
}

template <typename IntT, typename ObjT>
inline bool ObjectIndexer<IntT,ObjT>::included(tTPtr o) const {
  return objectIndex.find(o) != objectIndex.end();
}

template <typename IntT, typename ObjT>
inline bool ObjectIndexer<IntT,ObjT>::included(IntT i) const {
  return indexObject.find(i) != indexObject.end();
}

template <typename IntT, typename ObjT>
inline void ObjectIndexer<IntT,ObjT>::clear() {
  indexObject.clear();
  objectIndex.clear();
}

}
