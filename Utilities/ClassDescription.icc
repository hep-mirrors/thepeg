// -*- C++ -*-
//
// ClassDescription.icc is a part of ThePEG - Toolkit for HEP Event Generation
// Copyright (C) 1999-2007 Leif Lonnblad
//
// ThePEG is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of the
// ClassDescriptionBase, ClassDescriptionTBase, ClassDescription,
// AbstractClassDescription, NoPIOClassDescription and
// AbstractNoPIOClassDescription, classes.
//

namespace ThePEG {

inline ClassDescriptionBase::
ClassDescriptionBase(string newName, const type_info & newInfo,
		     int newVersion, string newLibrary, bool abst)
  : Named(newName), theVersion(newVersion), theLibrary(newLibrary),
    theInfo(newInfo), isAbstract(abst), done(false) {
}

inline ClassDescriptionBase::~ClassDescriptionBase() {}

inline const type_info & ClassDescriptionBase::info() const {
  return theInfo;
}

inline int ClassDescriptionBase::version() const {
  return theVersion;
}

inline string ClassDescriptionBase::library() const {
  return theLibrary;
}

inline bool ClassDescriptionBase::check() const {
  return done;
}

inline bool ClassDescriptionBase::abstract() const {
  return isAbstract;
}

inline const ClassDescriptionBase::DescriptionVector &
ClassDescriptionBase::descriptions() const {
  return theBaseClasses;
}

void ClassDescriptionBase::baseClasses(DescriptionVector::iterator first,
				       DescriptionVector::iterator last) {
  theBaseClasses = DescriptionVector(first, last);
  done = true;
}

template <typename T>
inline ClassDescriptionTBase<T>::ClassDescriptionTBase(bool abst)
  : ClassDescriptionBase(Traits::className(), typeid(T), Traits::version(),
			 Traits::library(), abst) {
  DescriptionList::Register(*this);
  T::Init();
}

template <typename T>
inline ClassDescriptionTBase<T>::~ClassDescriptionTBase() {}

template <typename T>
inline void ClassDescriptionTBase<T>::setup() {
  DescriptionVector bases;
  ClassDescriptionHelper<T,1>::addBases(bases);
  baseClasses(bases.begin(), bases.end());
}

template <typename T>
inline ClassDescription<T>::ClassDescription()
  : ClassDescriptionTBase<T>(false) {}

template <typename T>
inline BPtr ClassDescription<T>::create() const {
  return Traits::create();
}

template <typename T>
inline void ClassDescription<T>::
output(tcBPtr b, PersistentOStream & os) const {
  Traits::output(Traits::cast(b), os);
}

template <typename T>
inline void ClassDescription<T>::
input(tBPtr b, PersistentIStream & is, int oldVersion) const {
  Traits::input(Traits::cast(b), is, oldVersion);
}

template <typename T>
inline AbstractClassDescription<T>::AbstractClassDescription()
  : ClassDescriptionTBase<T>(true) {}

template <typename T>
inline BPtr AbstractClassDescription<T>::create() const {
  throw std::logic_error("Tried to instantiate virtual class " + Named::name());
}

template <typename T>
inline void AbstractClassDescription<T>::
output(tcBPtr b, PersistentOStream & os) const {
  Traits::output(Traits::cast(b), os);
}

template <typename T>
inline void AbstractClassDescription<T>::
input(tBPtr b, PersistentIStream & is, int oldVersion) const {
  Traits::input(Traits::cast(b), is, oldVersion);
}

template <typename T>
inline NoPIOClassDescription<T>::NoPIOClassDescription()
  : ClassDescriptionTBase<T>(false) {}

template <typename T>
inline BPtr NoPIOClassDescription<T>::create() const {
  return Traits::create();
}

template <typename T>
inline void NoPIOClassDescription<T>::
output(tcBPtr, PersistentOStream &) const {
}

template <typename T>
inline void NoPIOClassDescription<T>::
input(tBPtr, PersistentIStream &, int) const {
}

template <typename T>
inline AbstractNoPIOClassDescription<T>::AbstractNoPIOClassDescription()
  : ClassDescriptionTBase<T>(true) {}

template <typename T>
inline BPtr
AbstractNoPIOClassDescription<T>::create() const {
  throw std::logic_error("Tried to instantiate virtual class " + Named::name());
}

template <typename T>
inline void AbstractNoPIOClassDescription<T>::
output(tcBPtr, PersistentOStream &) const {
}

template <typename T>
inline void AbstractNoPIOClassDescription<T>::
input(tBPtr, PersistentIStream &, int) const {
}

}
