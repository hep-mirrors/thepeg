// -*- C++ -*-

namespace ThePEG {

template <typename T, typename CMP>
inline Interval<T,CMP>::Interval()
  : theLimits(pair<T,T>()) {}

template <typename T, typename CMP>
inline Interval<T,CMP>::Interval(T dn, T up)
  : theLimits(pair<T,T>(dn, up)) {}

template <typename T, typename CMP>
inline Interval<T,CMP>::Interval(const Interval & i)
  : theLimits(i.theLimits) {}

template <typename T, typename CMP>
inline const Interval<T,CMP> & Interval<T,CMP>::operator=(const Interval & i) {
  lower(i.lower());
  upper(i.upper());
  return *this;
}

template <typename T, typename CMP>
inline bool Interval<T,CMP>::operator==(const Interval & i) const {
  return lower() == i.lower() && upper() == i.upper();
}

template <typename T, typename CMP>
inline bool Interval<T,CMP>::operator<(const Interval & i) const {
  return cmp(lower(), i.lower()) ||
    ( lower() == i.lower() && cmp(upper(), i.upper()) );
}

template <typename T, typename CMP>
inline bool Interval<T,CMP>::check() const {
 return cmp(lower(), upper());
}

template <typename T, typename CMP>
inline bool Interval<T,CMP>::includes(T x) const {
  return !cmp(x, lower()) && cmp(x, upper());
}

template <typename T, typename CMP>
inline bool Interval<T,CMP>::operator()(T x) const {
  return includes(x);
}

template <typename T, typename CMP>
inline bool Interval<T,CMP>::includes(const Interval<T,CMP> & i) const {
  return includes(i.lower()) && !cmp(upper(), i.upper());
}

template <typename T, typename CMP>
inline Interval<T,CMP> Interval<T,CMP>::chopUpper(T x) {
  Interval<T,CMP> r;
  if ( includes(x) ) {
    r.lower(x);
    r.upper(upper());
      upper(x);
  }
  return r;
}

template <typename T, typename CMP>
inline Interval<T,CMP> Interval<T,CMP>::chopLower(T x) {
  Interval<T,CMP> r;
  if ( includes(x) ) {
    r.lower(lower());
    r.upper(x);
    lower(x);
  }
  return r;
}
    
template <typename T, typename CMP>
inline Interval<T,CMP> Interval<T,CMP>::overlap(const Interval & i) const {
  Interval<T,CMP> res;
  if ( operator==(i) ) res = i;
  if ( includes(i.upper()) || includes(i.lower()) )
    res = Interval<T,CMP>(max(lower(),i.lower()), min(upper(), i.upper()));
  return res;
}

template <typename T, typename CMP>
inline Interval<T,CMP> Interval<T,CMP>::sum(const Interval & i) const {
  Interval<T,CMP> res;
  if ( operator==(i) ) res = i;
  if ( includes(i.upper()) || includes(i.lower()) )
    res = Interval<T,CMP>(min(lower(),i.lower()), max(upper(), i.upper()));
  return res;
}

template <typename T, typename CMP>
inline T Interval<T,CMP>::upper() const {
  return theLimits.second;
}

template <typename T, typename CMP>
inline T Interval<T,CMP>::lower() const {
  return theLimits.first;
}

template <typename T, typename CMP>
inline void Interval<T,CMP>::upper(T up) {
  theLimits.second = up;
}

template <typename T, typename CMP>
inline void Interval<T,CMP>::lower(T dn) {
  theLimits.first = dn;
}

template <typename T, typename CMP>
template <typename Iterator>
inline bool Interval<T,CMP>::check(Iterator first, Iterator last) {
  while ( first != last ) if ( (*first++)(x) ) return true;
  return false;
}

template <typename T, typename CMP>
template <typename Iterator>
inline bool Interval<T,CMP>::checkAll(Iterator first, Iterator last) {
  while ( first != last ) if ( !(*first++)(x) ) return false;
  return true;
}

template <typename T, typename CMP>
inline Interval<T,CMP> makeInterval(T dn, T up) {
  return Interval<T,CMP>(dn, up);
}

template <typename OStream, typename T, typename CMP>
inline OStream & operator<<(OStream & os, const Interval<T,CMP> & i) {
  os << i.lower() << i.upper();
  return os;
}

template <typename IStream, typename T, typename CMP>
inline IStream & operator>>(IStream & is, Interval<T,CMP> & i) {
  T up, dn;
  is >> dn >> up;
  i.lower(dn);
  i.upper(up);
  return is;
}

}
