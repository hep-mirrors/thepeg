// -*- C++ -*-

namespace ThePEG {

namespace Math {

inline double exp1m(double x) {
#ifndef ThePEG_HAS_EXPM1
  return 2.0*std::exp(x/2.0)*std::sinh(-x/2.0);
#else
  return -expm1(x);
#endif
}

inline double log1m(double x) {
#ifndef ThePEG_HAS_LOG1P
  return 2.0*atanh(x/(x-2.0));
#else
  return log1p(-x);
#endif
}

double powi(double x, int i) {
  switch ( i ) {
  case 0: return 1.0;
  case -1: return 1/x;
  case -2: return 1/x/x;
  case -3: return 1/x/x/x;
  case 1: return x;
  case 2: return x*x;
  case 3: return x*x*x;
  default: return i > 0? powi(x, i - 1)*x: powi(x, i + 1)/x;
  }
}
 
inline double pIntegrate(double p, double xl, double xu) {
  return p == -1.0? log(xu/xl): (pow(xu, p + 1.0) - pow(xl, p + 1.0))/(p + 1.0);
}

inline double pIntegrate(int p, double xl, double xu) {
  return p == -1? log(xu/xl): (powi(xu, p + 1) - powi(xl, p + 1))/double(p + 1);
}

inline double pGenerate(double p, double xl, double xu, double rnd) {
  return p == -1.0? xl*pow(xu/xl, rnd):
    pow((1.0 - rnd)*pow(xl, p + 1.0) + rnd*pow(xu, p + 1.0), 1.0/(1.0 + p));
}

inline double pGenerate(int p, double xl, double xu, double rnd) {
  return p == -1? xl*pow(xu/xl, rnd):
    pow((1.0 - rnd)*powi(xl, p + 1) + rnd*powi(xu, p + 1), 1.0/double(1 + p));
}

inline double pXIntegrate(double e, double xl, double dx) {
  return e == 0.0? log1m(-dx/xl): -pow(xl, e)*exp1m(e*log1m(-dx/xl))/e;
}

inline double pXGenerate(double e, double xl, double dx, double rnd) {
  return e == 0.0? -xl*exp1m(rnd*log1m(-dx/xl)):
    -exp1m(log1m(rnd*exp1m(e*log1m(-dx/xl)))/e)*xl;
}

template <typename FloatType>
inline double relativeError(FloatType x, FloatType y) {
  return ( x == y? 0.0: (x - y)/(abs(x) + abs(y)) );
}

template <typename T>
inline T absmin(const T & x, const T & y) {
  return abs(x) < abs(y)? x: y;
}

template <typename T>
inline T absmax(const T & x, const T & y) {
  return abs(x) > abs(y)? x: y;
}

template <typename T, typename U>
inline T sign(T x, U y) {
  return y > 0? abs(x): -abs(x);
}

template <int N>
struct Power<N,false> {
  inline static double pow(double x) {
    return x*Power<N-1,false>::pow(x);
  }
};

template <int N>
struct Power<N,true> {
  inline static double pow(double x) {
    return Power<N+1,true>::pow(x)/x;
  }
};

template <>
struct Power<0,true> {
  inline static double pow(double x) {
    return 1.0;
  }
};

template <>
struct Power<0,false> {
  inline static double pow(double x) {
    return 1.0;
  }
};

}

template <int N>
inline double Math::Functions::PowX<N>::primitive(double x) {
  return Pow<N+1>(x)/double(N+1);
}

template <int N>
inline double Math::Functions::PowX<N>::integrate(double x0, double x1) {
  return primitive(x1) - primitive(x0);
}

template <int N>
inline double Math::Functions::PowX<N>::
generate(double x0, double x1, double R) {
  return pow(primitive(x0) + R*integrate(x0, x1), 1.0/double(N+1));
}

template <>
inline double Math::Functions::PowX<1>::
generate(double x0, double x1, double R) {
  return std::sqrt(x0*x0 + R*(x1*x1 - x0*x0));
}

template <>
inline double Math::Functions::PowX<0>::
generate(double x0, double x1, double R) {
  return x0 + R*(x1 - x0);
}

template<>
inline double Math::Functions::PowX<-1>::primitive(double x) {
  return log(x);
}

template <>
inline double Math::Functions::PowX<-1>::integrate(double x0, double x1) {
  return log(x1/x0);
}

template <>
inline double Math::Functions::PowX<-1>::
generate(double x0, double x1, double R) {
  return x0*pow(x1/x0, R);
}

template <>
inline double Math::Functions::PowX<-2>::
generate(double x0, double x1, double R) {
  return x0*x1/(x1 - R*(x1 - x0));
}

template <>
inline double Math::Functions::PowX<-3>::
generate(double x0, double x1, double R) {
  return x0*x1/std::sqrt(x1*x1 - R*(x1*x1 - x0*x0));
}

template <int N>
inline double Math::Functions::Pow1mX<N>::primitive(double x) {
  return -PowX<N>::primitive(1.0 - x);
}

template <int N>
inline double Math::Functions::Pow1mX<N>::integrate(double x0, double x1) {
  return PowX<N>::integrate(1.0 - x1, 1.0 - x0);
}

template <int N>
inline double Math::Functions::Pow1mX<N>::
generate(double x0, double x1, double R) {
  return 1.0 - PowX<N>::generate(1.0 - x1, 1.0 - x0, R);
}

inline double Math::Functions::InvX1mX::primitive(double x) {
  return log(x/(1.0 - x));
}

inline double Math::Functions::InvX1mX::integrate(double x0, double x1) {
  return log(x1*(1.0 - x0)/(x0*(1.0 - x1)));
}

inline double Math::Functions::InvX1mX::
generate(double x0, double x1, double R) {
  double r = pow(x1*(1.0 - x0)/(x0*(1.0 - x1)), R)*x0/(1.0 - x0);
  return r/(1.0 + r);
}

inline double Math::Functions::ExpX::primitive(double x) {
  return exp(x);
}

inline double Math::Functions::ExpX::integrate(double x0, double x1) {
  return exp(x1) - exp(x0);
}

inline double Math::Functions::ExpX::
generate(double x0, double x1, double R) {
  return log(exp(x0) + R*(exp(x1) - exp(x0)));
}

template <int N, int D>
inline double Math::Functions::FracPowX<N,D>::primitive(double x) {
  double r = double(N)/double(D) + 1.0;
  return pow(x, r)/r;
}

template <int N, int D>
inline double Math::Functions::FracPowX<N,D>::integrate(double x0, double x1) {
  return primitive(x1) - primitive(x0);
}

template <int N, int D>
inline double Math::Functions::FracPowX<N,D>::
generate(double x0, double x1, double R) {
  double r = double(N)/double(D) + 1.0;
  return pow(primitive(x0) + R*integrate(x0, x1), 1.0/r);
}

}

